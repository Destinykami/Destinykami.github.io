---
title: 'rCore-ch5'
date: 2024/1/15
permalink: /posts/2024/01/rCore_ch5/
excerpt: 'ç¬¬äº”ç«  è¿›ç¨‹'
tags:
  - rCore
  - OS
---
åœ¨æœ¬ç« ä¸­ï¼Œæ–°å¢**è¿›ç¨‹æ§åˆ¶å—**  (PCB,Process Control Block)ï¼Œå­˜æ”¾æ¯ä¸ªè¿›ç¨‹çš„æ‰§è¡ŒçŠ¶æ€ã€èµ„æºæ§åˆ¶ç­‰å…ƒæ•°æ®ã€‚å®ƒæ˜¯å†…æ ¸å¯¹è¿›ç¨‹è¿›è¡Œç®¡ç†çš„å•ä½ï¼Œæ•…è€Œæ˜¯ä¸€ç§æå…¶å…³é”®çš„å†…æ ¸æ•°æ®ç»“æ„ã€‚  
æ‰¿æ¥å‰é¢çš„ç« èŠ‚ï¼Œæˆ‘ä»¬ä»…éœ€å¯¹ä»»åŠ¡æ§åˆ¶å— `TaskControlBlock` è¿›è¡Œè‹¥å¹²æ”¹åŠ¨å¹¶è®©å®ƒç›´æ¥æ‰¿æ‹…è¿›ç¨‹æ§åˆ¶å—çš„åŠŸèƒ½ï¼š
``` rust
// os/src/task/task.rs

pub struct TaskControlBlock {
    // immutable
    pub pid: PidHandle,
    pub kernel_stack: KernelStack,
    // mutable
    inner: UPSafeCell<TaskControlBlockInner>,
}

pub struct TaskControlBlockInner {
    pub trap_cx_ppn: PhysPageNum,
    pub base_size: usize,
    pub task_cx: TaskContext,
    pub task_status: TaskStatus,
    pub memory_set: MemorySet,
    pub parent: Option<Weak<TaskControlBlock>>,
    pub children: Vec<Arc<TaskControlBlock>>,
    pub exit_code: i32,
}
```
ä½œä¸ºå¯¹æ¯”ï¼Œåœ¨è¿™é‡Œé™„ä¸Šå‰é¢ç« èŠ‚çš„TCBç»“æ„ï¼š
```rust
pub struct TaskControlBlock {
    /// Save task context
    pub task_cx: TaskContext,
    /// Maintain the execution status of the current process
    pub task_status: TaskStatus,
    /// Application address space
    pub memory_set: MemorySet,
    /// The phys page number of trap context
    pub trap_cx_ppn: PhysPageNum,
    /// The size(top addr) of program which is loaded from elf file
    pub base_size: usize,
    /// Heap bottom
    pub heap_bottom: usize,
    /// Program break
    pub program_brk: usize,
    /// start_time
    pub start_time: usize,
    /// syscall_times
    pub syscall_times: [u32;MAX_SYSCALL_NUM],
}
```

ä»»åŠ¡æ§åˆ¶å—ä¸­åŒ…å«ä¸¤éƒ¨åˆ†ï¼š

åœ¨åˆå§‹åŒ–ä¹‹åå°±ä¸å†å˜åŒ–çš„å…ƒæ•°æ®ï¼šç›´æ¥æ”¾åœ¨ä»»åŠ¡æ§åˆ¶å—ä¸­ã€‚è¿™é‡Œå°†è¿›ç¨‹æ ‡è¯†ç¬¦ `PidHandle` å’Œå†…æ ¸æ ˆ `KernelStack` æ”¾åœ¨å…¶ä¸­ï¼›

åœ¨è¿è¡Œè¿‡ç¨‹ä¸­å¯èƒ½å‘ç”Ÿå˜åŒ–çš„å…ƒæ•°æ®ï¼šåˆ™æ”¾åœ¨ `TaskControlBlockInner` ä¸­ï¼Œå°†å®ƒå†åŒ…è£¹ä¸Šä¸€å±‚ `UPSafeCell<T>` æ”¾åœ¨ä»»åŠ¡æ§åˆ¶å—ä¸­ã€‚è¿™æ˜¯å› ä¸ºåœ¨æˆ‘ä»¬çš„è®¾è®¡ä¸­å¤–å±‚åªèƒ½è·å–ä»»åŠ¡æ§åˆ¶å—çš„ä¸å¯å˜å¼•ç”¨ï¼Œè‹¥æƒ³ä¿®æ”¹é‡Œé¢çš„éƒ¨åˆ†å†…å®¹çš„è¯è¿™éœ€è¦ `UPSafeCell<T>`æ‰€æä¾›çš„å†…éƒ¨å¯å˜æ€§ã€‚  
æ³¨æ„æˆ‘ä»¬åœ¨ç»´æŠ¤çˆ¶å­è¿›ç¨‹å…³ç³»çš„æ—¶å€™å¤§é‡ç”¨åˆ°äº†å¼•ç”¨è®¡æ•° `Arc/Weak` ã€‚è¿›ç¨‹æ§åˆ¶å—çš„æœ¬ä½“æ˜¯è¢«æ”¾åˆ°å†…æ ¸å †ä¸Šé¢çš„ï¼Œå¯¹äºå®ƒçš„ä¸€åˆ‡è®¿é—®éƒ½æ˜¯é€šè¿‡æ™ºèƒ½æŒ‡é’ˆ `Arc/Weak` æ¥è¿›è¡Œçš„ï¼Œè¿™æ ·æ˜¯ä¾¿äºå»ºç«‹çˆ¶å­è¿›ç¨‹çš„åŒå‘é“¾æ¥å…³ç³»ï¼ˆé¿å…ä»…åŸºäº `Arc` å½¢æˆç¯çŠ¶é“¾æ¥å…³ç³»ï¼‰ã€‚å½“ä¸”ä»…å½“æ™ºèƒ½æŒ‡é’ˆ `Arc` çš„å¼•ç”¨è®¡æ•°å˜ä¸º `0` çš„æ—¶å€™ï¼Œè¿›ç¨‹æ§åˆ¶å—ä»¥åŠè¢«ç»‘å®šåˆ°å®ƒä¸Šé¢çš„å„ç±»èµ„æºæ‰ä¼šè¢«å›æ”¶ã€‚å­è¿›ç¨‹çš„è¿›ç¨‹æ§åˆ¶å—å¹¶ä¸ä¼šè¢«ç›´æ¥æ”¾åˆ°çˆ¶è¿›ç¨‹æ§åˆ¶å—ä¸­ï¼Œå› ä¸ºå­è¿›ç¨‹å®Œå…¨æœ‰å¯èƒ½åœ¨çˆ¶è¿›ç¨‹é€€å‡ºåä»ç„¶å­˜åœ¨ã€‚    

`TaskControlBlockInner` æä¾›çš„æ–¹æ³•ä¸»è¦æ˜¯å¯¹äºå®ƒå†…éƒ¨çš„å­—æ®µçš„å¿«æ·è®¿é—®ï¼š

```rust
// os/src/task/task.rs

impl TaskControlBlockInner {
    pub fn get_trap_cx(&self) -> &'static mut TrapContext {
        self.trap_cx_ppn.get_mut()
    }
    pub fn get_user_token(&self) -> usize {
        self.memory_set.token()
    }
    fn get_status(&self) -> TaskStatus {
        self.task_status
    }
    pub fn is_zombie(&self) -> bool {
        self.get_status() == TaskStatus::Zombie
    }
}
```
è€Œä»»åŠ¡æ§åˆ¶å— `TaskControlBlock` ç›®å‰æä¾›ä»¥ä¸‹æ–¹æ³•ï¼š
```rust
// os/src/task/task.rs

impl TaskControlBlock {
    pub fn inner_exclusive_access(&self) -> RefMut<'_, TaskControlBlockInner> {
        self.inner.exclusive_access()
    }
    pub fn getpid(&self) -> usize {
        self.pid.0
    }
    pub fn new(elf_data: &[u8]) -> Self {...}
    pub fn exec(&self, elf_data: &[u8]) {...}
    pub fn fork(self: &Arc<TaskControlBlock>) -> Arc<TaskControlBlock> {...}
}
```

* `inner_exclusive_access` é€šè¿‡ `UPSafeCell<T>.exclusive_access()` æ¥å¾—åˆ°ä¸€ä¸ª `RefMut<'_, TaskControlBlockInner>` ï¼Œå®ƒå¯ä»¥è¢«çœ‹æˆä¸€ä¸ªå†…å±‚ `TaskControlBlockInner` çš„å¯å˜å¼•ç”¨å¹¶å¯ä»¥å¯¹å®ƒæŒ‡å‘çš„å†…å®¹è¿›è¡Œä¿®æ”¹ã€‚

* `getpid` ä»¥ `usize` çš„å½¢å¼è¿”å›å½“å‰è¿›ç¨‹çš„è¿›ç¨‹æ ‡è¯†ç¬¦ã€‚

* `new` ç”¨æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„è¿›ç¨‹ï¼Œç›®å‰ä»…ç”¨äºå†…æ ¸ä¸­æ‰‹åŠ¨åˆ›å»ºå”¯ä¸€ä¸€ä¸ªåˆå§‹è¿›ç¨‹ `initproc` ã€‚

* `exec` ç”¨æ¥å®ç° `exec` ç³»ç»Ÿè°ƒç”¨ï¼Œå³å½“å‰è¿›ç¨‹åŠ è½½å¹¶æ‰§è¡Œå¦ä¸€ä¸ª `ELF` æ ¼å¼å¯æ‰§è¡Œæ–‡ä»¶ã€‚

* `fork` ç”¨æ¥å®ç° `fork` ç³»ç»Ÿè°ƒç”¨ï¼Œå³å½“å‰è¿›ç¨‹ `fork` å‡ºæ¥ä¸€ä¸ªä¸ä¹‹å‡ ä¹ç›¸åŒçš„å­è¿›ç¨‹ã€‚

>è¿™é‡Œæ˜¯æˆ‘æ¯”è¾ƒè´¹è§£çš„åœ°æ–¹ï¼Œä¸€å¼€å§‹æ²¡æœ‰æ³¨æ„åˆ°ï¼Œåœ¨ç¼–ç¨‹ä¸­å¤ç”¨ch4çš„mmapå’Œmunmapå‡ºç°äº†é—®é¢˜ï¼Œåå¤å¯¹æ¯”æºç å’ŒæŸ¥é˜…æ–‡æ¡£å‘ç°æ˜¯TCBæ˜¯è¢«ä¿®æ”¹è¿‡çš„ï¼Œä¸èƒ½åƒä¹‹å‰é‚£æ ·è®¿é—®æˆå‘˜ã€‚
```rust
    ///ch5: mmap
    pub fn mmap(&self,start: usize, len: usize, port: usize)->isize{
        let mut inner=self.inner.exclusive_access();
        let start_va=mm::VirtAddr::from(start);
        let end_va=mm::VirtAddr::from(start+len);
        //éå†äº†è™šæ‹Ÿåœ°å€èŒƒå›´å†…çš„æ‰€æœ‰è™šæ‹Ÿé¡µ
        for vpn in mm::VPNRange::new(start_va.floor(),end_va.ceil()){
            if let Some(pte) =  inner.memory_set.translate(vpn){
                if pte.is_valid(){
                    return -1;
                }
            }
        }
        let map_permission: mm::MapPermission = MapPermission::from_bits((port as u8) << 1).unwrap() | MapPermission::U;
        inner.memory_set.insert_framed_area(start_va, end_va, map_permission);
        //æ£€æŸ¥ä»èµ·å§‹åœ°å€åˆ°ç»“æŸåœ°å€ä¸­æ˜¯å¦æœ‰æœªè¢«æ˜ å°„çš„å†…å­˜
        for vpn in mm::VPNRange::new(start_va.floor(),end_va.ceil()){
            match inner.memory_set.translate(vpn) {
                Some(pte)=>{
                    if pte.is_valid()==false{
                        return -1;
                    }
                }
                None => {
                    return -1;
                }
            }
        }
        0
    }
    ///ch5: munmap
    pub fn munmap(&self,start:usize,len:usize)->isize{
        let mut inner=self.inner.exclusive_access();
        let start_va=mm::VirtAddr::from(start);
        let end_va=mm::VirtAddr::from(start+len);
        //æ£€æŸ¥ä»èµ·å§‹åœ°å€åˆ°ç»“æŸåœ°å€ä¸­æ˜¯å¦æœ‰æœªè¢«æ˜ å°„çš„å†…å­˜
        for vpn in mm::VPNRange::new(start_va.floor(),end_va.ceil()){
            match inner.memory_set.translate(vpn) {
                Some(pte)=>{
                    if pte.is_valid()==false{
                        return -1;
                    }
                }
                None => {
                    return -1;
                }
            }
        }
        inner.memory_set.remove_area_with_start_vpn(mm::VirtPageNum::from(start_va));//æŒ‰ç…§è™šé¡µå·åˆ é™¤ï¼Œæºä»£ç ä¸­æä¾›ï¼Œä¸åƒch4éœ€è¦è‡ªå·±å®ç°
        0
    }
```
## ç¼–ç¨‹ä½œä¸š
å¤§å®¶ä¸€å®šå¥½å¥‡è¿‡ä¸ºå•¥è¿›ç¨‹åˆ›å»ºè¦ç”¨ `fork + execve` è¿™ä¹ˆä¸€ä¸ªå¥‡æ€ªçš„ç³»ç»Ÿè°ƒç”¨ï¼Œå°±ä¸èƒ½ç›´æ¥æä¸€ä¸ªæ–°è¿›ç¨‹å—ï¼Ÿæ€è€Œä¸å­¦åˆ™æ®†ï¼Œæˆ‘ä»¬å°±æ¥è¯•ä¸€è¯•ï¼è¿™ç« çš„ç¼–ç¨‹ç»ƒä¹ è¯·å¤§å®¶å®ç°ä¸€ä¸ªå®Œå…¨ DIY çš„ç³»ç»Ÿè°ƒç”¨ `spawn`ï¼Œç”¨ä»¥åˆ›å»ºä¸€ä¸ªæ–°è¿›ç¨‹ã€‚

`spawn` ç³»ç»Ÿè°ƒç”¨å®šä¹‰

```rust
fn sys_spawn(path: *const u8) -> isize
```
* syscall ID: 400

* åŠŸèƒ½ï¼šæ–°å»ºå­è¿›ç¨‹ï¼Œä½¿å…¶æ‰§è¡Œç›®æ ‡ç¨‹åºã€‚

è¯´æ˜ï¼šæˆåŠŸè¿”å›å­è¿›ç¨‹idï¼Œå¦åˆ™è¿”å› -1ã€‚

å¯èƒ½çš„é”™è¯¯ï¼š
* æ— æ•ˆçš„æ–‡ä»¶åã€‚

* è¿›ç¨‹æ± æ»¡/å†…å­˜ä¸è¶³ç­‰èµ„æºé”™è¯¯ã€‚

TIPSï¼šè™½ç„¶æµ‹ä¾‹å¾ˆç®€å•ï¼Œä½†æé†’è¯»è€… `spawn` **ä¸å¿…** åƒ `fork` ä¸€æ ·å¤åˆ¶çˆ¶è¿›ç¨‹çš„åœ°å€ç©ºé—´ã€‚

> è¿™é‡Œç›´æ¥ç¼åˆforkå’Œexecä¸¤ä¸ªå‡½æ•°ã€‚çœŸå°±fork+exec=spawn ğŸ¤£

```rust
//os/src/task/task.rs
    ///spawn
    pub fn spawn(self:&Arc<TaskControlBlock>,elf_data: &[u8])->Arc<TaskControlBlock>{
        let mut parent_inner=self.inner_exclusive_access();// æ¥è‡ªfork
        let (memory_set,user_sp,entry_point)=MemorySet::from_elf(elf_data); //æ¥è‡ªexec
        let trap_cx_ppn=memory_set.translate(VirtAddr::from(TRAP_CONTEXT_BASE).into()).unwrap().ppn();//æ¥è‡ªexec
        let pid_handle=pid_alloc();//æ¥è‡ªfork
        let kernel_stack=kstack_alloc();//åˆ†é…æ–°çš„å†…æ ¸æ ˆ
        let kernel_stack_top=kernel_stack.get_top();
        let task_control_block=Arc::new(Self{
            pid:pid_handle,
            kernel_stack,
            inner:unsafe{
                UPSafeCell::new(TaskControlBlockInner { 
                    trap_cx_ppn, 
                    base_size: user_sp, 
                    task_cx: TaskContext::goto_trap_return(kernel_stack_top), 
                    task_status: TaskStatus::Ready, 
                    memory_set, 
                    parent: Some(Arc::downgrade(self)), 
                    children: Vec::new(), 
                    exit_code: 0, 
                    heap_bottom: user_sp, 
                    program_brk: user_sp, 
                    stride:0,
                    priority:16,
                })
            },
        });
        parent_inner.children.push(task_control_block.clone());
        let trap_cx=task_control_block.inner_exclusive_access().get_trap_cx();
        *trap_cx=TrapContext::app_init_context(
          entry_point, 
          user_sp, 
          KERNEL_SPACE.exclusive_access().token(),
          kernel_stack_top, 
          trap_handler as usize
        );

        task_control_block
    }

//os/src/syscall/sys_spawn


/// YOUR JOB: Implement spawn.
/// HINT: fork + exec =/= spawn
pub fn sys_spawn(path: *const u8) -> isize {
    trace!(
        "kernel:pid[{}] sys_spawn NOT IMPLEMENTED",
        current_task().unwrap().pid.0
    );
    let token=current_user_token();
    let path=translated_str(token, path);
    if let Some(data)=get_app_data_by_name(path.as_str()){
        let current_task=current_task().unwrap();
        let task=current_task.spawn(data);
        let pid=task.getpid();
        add_task(task);
        pid as isize
    }
    else {
        -1
    }
}  
```rust