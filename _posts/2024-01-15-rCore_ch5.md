---
title: 'rCore-ch5'
date: 2024/1/15
permalink: /posts/2024/01/rCore_ch5/
excerpt: '第五章 进程'
tags:
  - rCore
  - OS
---
在本章中，新增**进程控制块**  (PCB,Process Control Block)，存放每个进程的执行状态、资源控制等元数据。它是内核对进程进行管理的单位，故而是一种极其关键的内核数据结构。  
承接前面的章节，我们仅需对任务控制块 `TaskControlBlock` 进行若干改动并让它直接承担进程控制块的功能：
``` rust
// os/src/task/task.rs

pub struct TaskControlBlock {
    // immutable
    pub pid: PidHandle,
    pub kernel_stack: KernelStack,
    // mutable
    inner: UPSafeCell<TaskControlBlockInner>,
}

pub struct TaskControlBlockInner {
    pub trap_cx_ppn: PhysPageNum,
    pub base_size: usize,
    pub task_cx: TaskContext,
    pub task_status: TaskStatus,
    pub memory_set: MemorySet,
    pub parent: Option<Weak<TaskControlBlock>>,
    pub children: Vec<Arc<TaskControlBlock>>,
    pub exit_code: i32,
}
```
作为对比，在这里附上前面章节的TCB结构：
```rust
pub struct TaskControlBlock {
    /// Save task context
    pub task_cx: TaskContext,
    /// Maintain the execution status of the current process
    pub task_status: TaskStatus,
    /// Application address space
    pub memory_set: MemorySet,
    /// The phys page number of trap context
    pub trap_cx_ppn: PhysPageNum,
    /// The size(top addr) of program which is loaded from elf file
    pub base_size: usize,
    /// Heap bottom
    pub heap_bottom: usize,
    /// Program break
    pub program_brk: usize,
    /// start_time
    pub start_time: usize,
    /// syscall_times
    pub syscall_times: [u32;MAX_SYSCALL_NUM],
}
```

任务控制块中包含两部分：

在初始化之后就不再变化的元数据：直接放在任务控制块中。这里将进程标识符 `PidHandle` 和内核栈 `KernelStack` 放在其中；

在运行过程中可能发生变化的元数据：则放在 `TaskControlBlockInner` 中，将它再包裹上一层 `UPSafeCell<T>` 放在任务控制块中。这是因为在我们的设计中外层只能获取任务控制块的不可变引用，若想修改里面的部分内容的话这需要 `UPSafeCell<T>`所提供的内部可变性。  
注意我们在维护父子进程关系的时候大量用到了引用计数 `Arc/Weak` 。进程控制块的本体是被放到内核堆上面的，对于它的一切访问都是通过智能指针 `Arc/Weak` 来进行的，这样是便于建立父子进程的双向链接关系（避免仅基于 `Arc` 形成环状链接关系）。当且仅当智能指针 `Arc` 的引用计数变为 `0` 的时候，进程控制块以及被绑定到它上面的各类资源才会被回收。子进程的进程控制块并不会被直接放到父进程控制块中，因为子进程完全有可能在父进程退出后仍然存在。    

`TaskControlBlockInner` 提供的方法主要是对于它内部的字段的快捷访问：

```rust
// os/src/task/task.rs

impl TaskControlBlockInner {
    pub fn get_trap_cx(&self) -> &'static mut TrapContext {
        self.trap_cx_ppn.get_mut()
    }
    pub fn get_user_token(&self) -> usize {
        self.memory_set.token()
    }
    fn get_status(&self) -> TaskStatus {
        self.task_status
    }
    pub fn is_zombie(&self) -> bool {
        self.get_status() == TaskStatus::Zombie
    }
}
```
而任务控制块 `TaskControlBlock` 目前提供以下方法：
```rust
// os/src/task/task.rs

impl TaskControlBlock {
    pub fn inner_exclusive_access(&self) -> RefMut<'_, TaskControlBlockInner> {
        self.inner.exclusive_access()
    }
    pub fn getpid(&self) -> usize {
        self.pid.0
    }
    pub fn new(elf_data: &[u8]) -> Self {...}
    pub fn exec(&self, elf_data: &[u8]) {...}
    pub fn fork(self: &Arc<TaskControlBlock>) -> Arc<TaskControlBlock> {...}
}
```

* `inner_exclusive_access` 通过 `UPSafeCell<T>.exclusive_access()` 来得到一个 `RefMut<'_, TaskControlBlockInner>` ，它可以被看成一个内层 `TaskControlBlockInner` 的可变引用并可以对它指向的内容进行修改。

* `getpid` 以 `usize` 的形式返回当前进程的进程标识符。

* `new` 用来创建一个新的进程，目前仅用于内核中手动创建唯一一个初始进程 `initproc` 。

* `exec` 用来实现 `exec` 系统调用，即当前进程加载并执行另一个 `ELF` 格式可执行文件。

* `fork` 用来实现 `fork` 系统调用，即当前进程 `fork` 出来一个与之几乎相同的子进程。

>这里是我比较费解的地方，一开始没有注意到，在编程中复用ch4的mmap和munmap出现了问题，反复对比源码和查阅文档发现是TCB是被修改过的，不能像之前那样访问成员。
```rust
    ///ch5: mmap
    pub fn mmap(&self,start: usize, len: usize, port: usize)->isize{
        let mut inner=self.inner.exclusive_access();
        let start_va=mm::VirtAddr::from(start);
        let end_va=mm::VirtAddr::from(start+len);
        //遍历了虚拟地址范围内的所有虚拟页
        for vpn in mm::VPNRange::new(start_va.floor(),end_va.ceil()){
            if let Some(pte) =  inner.memory_set.translate(vpn){
                if pte.is_valid(){
                    return -1;
                }
            }
        }
        let map_permission: mm::MapPermission = MapPermission::from_bits((port as u8) << 1).unwrap() | MapPermission::U;
        inner.memory_set.insert_framed_area(start_va, end_va, map_permission);
        //检查从起始地址到结束地址中是否有未被映射的内存
        for vpn in mm::VPNRange::new(start_va.floor(),end_va.ceil()){
            match inner.memory_set.translate(vpn) {
                Some(pte)=>{
                    if pte.is_valid()==false{
                        return -1;
                    }
                }
                None => {
                    return -1;
                }
            }
        }
        0
    }
    ///ch5: munmap
    pub fn munmap(&self,start:usize,len:usize)->isize{
        let mut inner=self.inner.exclusive_access();
        let start_va=mm::VirtAddr::from(start);
        let end_va=mm::VirtAddr::from(start+len);
        //检查从起始地址到结束地址中是否有未被映射的内存
        for vpn in mm::VPNRange::new(start_va.floor(),end_va.ceil()){
            match inner.memory_set.translate(vpn) {
                Some(pte)=>{
                    if pte.is_valid()==false{
                        return -1;
                    }
                }
                None => {
                    return -1;
                }
            }
        }
        inner.memory_set.remove_area_with_start_vpn(mm::VirtPageNum::from(start_va));//按照虚页号删除，源代码中提供，不像ch4需要自己实现
        0
    }
```
## 编程作业
大家一定好奇过为啥进程创建要用 `fork + execve` 这么一个奇怪的系统调用，就不能直接搞一个新进程吗？思而不学则殆，我们就来试一试！这章的编程练习请大家实现一个完全 DIY 的系统调用 `spawn`，用以创建一个新进程。

`spawn` 系统调用定义

```rust
fn sys_spawn(path: *const u8) -> isize
```
* syscall ID: 400

* 功能：新建子进程，使其执行目标程序。

说明：成功返回子进程id，否则返回 -1。

可能的错误：
* 无效的文件名。

* 进程池满/内存不足等资源错误。

TIPS：虽然测例很简单，但提醒读者 `spawn` **不必** 像 `fork` 一样复制父进程的地址空间。

> 这里直接缝合fork和exec两个函数。真就fork+exec=spawn 🤣

```rust
//os/src/task/task.rs
    ///spawn
    pub fn spawn(self:&Arc<TaskControlBlock>,elf_data: &[u8])->Arc<TaskControlBlock>{
        let mut parent_inner=self.inner_exclusive_access();// 来自fork
        let (memory_set,user_sp,entry_point)=MemorySet::from_elf(elf_data); //来自exec
        let trap_cx_ppn=memory_set.translate(VirtAddr::from(TRAP_CONTEXT_BASE).into()).unwrap().ppn();//来自exec
        let pid_handle=pid_alloc();//来自fork
        let kernel_stack=kstack_alloc();//分配新的内核栈
        let kernel_stack_top=kernel_stack.get_top();
        let task_control_block=Arc::new(Self{
            pid:pid_handle,
            kernel_stack,
            inner:unsafe{
                UPSafeCell::new(TaskControlBlockInner { 
                    trap_cx_ppn, 
                    base_size: user_sp, 
                    task_cx: TaskContext::goto_trap_return(kernel_stack_top), 
                    task_status: TaskStatus::Ready, 
                    memory_set, 
                    parent: Some(Arc::downgrade(self)), 
                    children: Vec::new(), 
                    exit_code: 0, 
                    heap_bottom: user_sp, 
                    program_brk: user_sp, 
                    stride:0,
                    priority:16,
                })
            },
        });
        parent_inner.children.push(task_control_block.clone());
        let trap_cx=task_control_block.inner_exclusive_access().get_trap_cx();
        *trap_cx=TrapContext::app_init_context(
          entry_point, 
          user_sp, 
          KERNEL_SPACE.exclusive_access().token(),
          kernel_stack_top, 
          trap_handler as usize
        );

        task_control_block
    }

//os/src/syscall/sys_spawn


/// YOUR JOB: Implement spawn.
/// HINT: fork + exec =/= spawn
pub fn sys_spawn(path: *const u8) -> isize {
    trace!(
        "kernel:pid[{}] sys_spawn NOT IMPLEMENTED",
        current_task().unwrap().pid.0
    );
    let token=current_user_token();
    let path=translated_str(token, path);
    if let Some(data)=get_app_data_by_name(path.as_str()){
        let current_task=current_task().unwrap();
        let task=current_task.spawn(data);
        let pid=task.getpid();
        add_task(task);
        pid as isize
    }
    else {
        -1
    }
}  
```rust