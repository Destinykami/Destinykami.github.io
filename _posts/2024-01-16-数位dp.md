---
title: '数位dp'
date: 2024/01/16
permalink: /posts/2024/01/digit_dp
excerpt: 'LeetCode 数位dp模板解题'
tags:
  - LeetCode
  - Algorithm
---
# 数位dp

参考自 @灵茶山艾府 

不得不说真是非常强..拿着这个模板进行改动能够直接秒掉一大堆题，甚至很多是Hard题。

## LeetCode.2376 统计特殊整数 Hard

[2376. 统计特殊整数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-special-integers/)

如果一个正整数每一个数位都是 **互不相同** 的，我们称它是 **特殊整数** 。

给你一个 **正** 整数 `n` ，请你返回区间 **`[1, n]`** 之间特殊整数的数目。

```python
class Solution:
    def countSpecialNumbers(self, n: int) -> int:
        #数位dp 模板
        s=str(n)
        @cache
        def f(i:int,mask:int,is_limit:bool,is_num:bool)->int:
            if i==len(s):
                return int(is_num)  #is_num=True时表示得到了一个合法数字
            res=0
            if not is_num: #当前可继续跳过 （在前导0里）
                res=f(i+1,mask,False,False)
            low =0 if is_num else 1 #如果前面没填数字，必须从1开始填
            up=int(s[i]) if is_limit else 9 # 如果前面填的数字都和 n 的一样，那么这一位至多填 s[i],否则就超过 n 
            for d in range(low,up+1):
                if(mask>>d&1)==0:#d不在mask中
                    res+=f(i+1,mask|(1<<d),is_limit and d==up,True)
            return res
        return f(0,0,True,False)
```

## LeetCode.357 统计各位数字都不同的数字个数  Midium

[357. 统计各位数字都不同的数字个数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-numbers-with-unique-digits/description/)

```python
class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -> int:
        n=10**n-1
        #数位dp 模板
        s=str(n)
        @cache
        def f(i:int,mask:int,is_limit:bool,is_num:bool)->int:
            if i==len(s):
                return int(is_num)  #is_num=True时表示得到了一个合法数字
            res=0
            if not is_num: #当前可继续跳过 （在前导0里）
                res=f(i+1,mask,False,False)
            low =0 if is_num else 1 #如果前面没填数字，必须从1开始填
            up=int(s[i]) if is_limit else 9 # 如果前面填的数字都和 n 的一样，那么这一位至多填 s[i],否则就超过 n 
            for d in range(low,up+1):
                if(mask>>d&1)==0:#d不在mask中
                    res+=f(i+1,mask|(1<<d),is_limit and d==up,True)
            return res
        return f(0,0,True,False)+1
```

这题标为Midium应该是因为可以用排列组合的做法 。（诶等等，这么说上面那题是不是也可以用排列组合）

```java
class Solution {
    public int countNumbersWithUniqueDigits(int n) {
        if (n == 0) return 1;
        int ans = 10;
        for (int i = 2, last = 9; i <= n; i++) {
            int cur = last * (10 - i + 1);
            ans += cur; 
						last = cur;
        }
        return ans;
    }
}
```

## LeetCode.1012 至少有一位重复的数字  Hard

[1012. 至少有 1 位重复的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/numbers-with-repeated-digits/description/)

给定正整数 `n`，返回在 **`[1, n]` **范围内具有 **至少 1 位** 重复数字的**正整数**的个数。

> 跟上面的思路基本上一样，不过上面是不能有重复，这个是至少一位重复。  （正整数：不能是0）
> 

```python
class Solution:
    def numDupDigitsAtMostN(self, n: int) -> int:
        #数位dp 模板
        s=str(n)
        @cache
        def f(i:int,mask:int,is_limit:bool,is_num:bool,is_duplicate)->int:
            #is_duplicate表示是否用过重复的数字
            if i==len(s):
                return int(is_num and is_duplicate)  #is_num=True且is_duplicate=True时表示得到了一个合法数字
            res=0
            if not is_num: #当前可继续跳过 （在前导0里）
                res=f(i+1,mask,False,False,False)
            low =0 if is_num else 1 #如果前面没填数字，必须从1开始填
            up=int(s[i]) if is_limit else 9 # 如果前面填的数字都和 n 的一样，那么这一位至多填 s[i],否则就超过 n 
            for d in range(low,up+1):
                if(mask>>d&1)==0:#d不在mask中
                    res+=f(i+1,mask|(1<<d),is_limit and d==up,True,is_duplicate)
                else:
                    res+=f(i+1,mask|(1<<d),is_limit and d==up,True,True)
            return res
        return f(0,0,True,False,False)
```

## LeetCode.233 数字1的个数 Hard

[233. 数字 1 的个数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-digit-one/description/)

给定一个整数 `n`，计算所有小于等于 `n` 的非负整数中数字 `1` 出现的个数。

> 套模板，变量改为统计数位1的个数即可
> 

```python
class Solution:
    def countDigitOne(self, n: int) -> int:
        #数位dp 模板
        s=str(n)
        @cache
        def f(i:int,is_limit:bool,digit_one:int)->int:
            if i==len(s):
                return digit_one
            res=0
            up=int(s[i]) if is_limit else 9 # 如果前面填的数字都和 n 的一样，那么这一位至多填 s[i],否则就超过 n 
            for d in range(0,up+1):
                if d==1:
                    res+=f(i+1,is_limit and d==up,digit_one+1)
                else:
                    res+=f(i+1,is_limit and d==up,digit_one)
            return res
        return f(0,True,0)
```

## LeetCode.2719 统计整数数目 Hard （2024/1/16每日一题）

[2719. 统计整数数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-of-integers/description/)

给你两个数字字符串 `num1` 和 `num2` ，以及两个整数 `max_sum` 和 `min_sum` 。如果一个整数 `x` 满足以下条件，我们称它是一个好整数：

- `num1 <= x <= num2`
- `min_sum <= digit_sum(x) <= max_sum`.

请你返回好整数的数目。答案可能很大，请返回答案对 `10^9 + 7` 取余后的结果。

注意，`digit_sum(x)` 表示 `x` 各位数字之和。

> 这里用了两次记忆化搜索，因为以上的模板是统计从0到n的符合条件的数的个数，这里两次搜索分别统计从0到num1和从0到num2的符合条件的数的个数，作差就可以得到(num1,num2]区间内符合条件的数的个数，特别的，需要判断num1是否符合条件，如果符合条件还需要在最后结果加上1。
> 

```python
class Solution:
    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:
        def help(s:str)->int:
            #数位dp 模板
            @cache
            def f(i:int,is_limit:bool,is_num:bool,digit_sum:int)->int:
                if(digit_sum>max_sum):
                    return 0
                #digit_sum为数位之和
                if i==len(s):
                    return digit_sum>=min_sum  
                res=0
                up=int(s[i]) if is_limit else 9 # 如果前面填的数字都和 n 的一样，那么这一位至多填 s[i],否则就超过 n 
                for d in range(0,up+1):
                    res+=f(i+1,is_limit and d==up,True,digit_sum+d)
                return res
            return f(0,True,False,0)
        is_num1_good = min_sum <= sum(map(int, num1)) <= max_sum  
        return (help(num2)-help(num1)+is_num1_good)%1_000_000_007
```

> 这里有数位dp模板2.0版本，只需要一次记忆化搜索，等待学习~
> 
- [ ]  todo—数位dp模板2.0

## LeetCode.902 最大为N的数字组合 Hard

[902. 最大为 N 的数字组合 - 力扣（LeetCode）](https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/description/)

给定一个按 **非递减顺序** 排列的数字数组 `digits` 。你可以用任意次数 `digits[i]` 来写的数字。例如，如果 `digits = ['1','3','5']`，我们可以写数字，如 `'13'`, `'551'`, 和 `'1351315'`。

返回 *可以生成的小于或等于给定整数 `n` 的正整数的个数* 。

```python
class Solution:
    def atMostNGivenDigitSet(self, digits: List[str], n: int) -> int:
        #数位dp 模板
        s=str(n)
        @cache
        def f(i:int,is_limit:bool,is_num:bool)->int:
            if i==len(s):
                return int(is_num)  #is_num=True时表示得到了一个合法数字
            res=0
            if not is_num: #当前可继续跳过 （在前导0里）
                res=f(i+1,False,False)
            up=s[i] if is_limit else '9' # 如果前面填的数字都和 n 的一样，那么这一位至多填 s[i],否则就超过 n 
            for d in digits:
                if d>up:
                    break
                res+=f(i+1,is_limit and d==up,True)
            return res
        return f(0,True,False)
```