---
title: '南京大学计算机基础PA2'
date: 2024/01/31
update: 2024/01/31
permalink: /posts/2024/01/nju-pa-2
excerpt: '南京大学计算机基础PA2'
tags:
  - OS
---
从PA2开始涉及到CPU的执行指令过程。  
在PA1中, 我们已经见识到最简单的计算机TRM的工作方式:
```c
while (1) {
  //从PC指示的存储器位置取出指令;
  //执行指令;
  //更新PC;
}
```
接下来我们就来谈谈这个过程, 也就是, CPU究竟是怎么执行一条指令的. 对于大部分指令来说, 执行它们都可以抽象成取指-译码-执行的指令周期. 为了使描述更加清晰, 我们借助指令周期中的一些概念来说明指令执行的过程.  

> *计组实验在攻击我！*   

## 取指(instruction fetch, IF)
取指令要做的事情自然就是将PC指向的指令从内存读入到CPU中.  


## 译码(instruction decode, ID)
在取指令阶段取到的当然是一堆01，需要把这指令解读出"操作码"和"操作数"两部分信息。CPU拿到一条指令之后, 可以通过查表的方式得知这条指令的操作数和操作码. 这个过程叫译码.

当然, 译码逻辑实际上也并非只有一张查找表那么简单, 还需要根据不同的指令通过多路选择器选择不同的操作数. 回想一下, 计算机现在已经有存储器和寄存器了, 它们都可以存放操作数, 指令中也可以存放立即数. 也可能还有二次译码的处理... 不过无论再怎么复杂, 我们只需要知道, 这个过程终究也只是一些数字电路的事情, 毕竟所有需要的信息都在指令里面了, 没什么神秘的操作.

## 执行(execute, EX)
经过译码之后, CPU就知道当前指令具体要做什么了, 执行阶段就是真正完成指令的工作. 现在TRM只有加法器这一个执行部件, 必要的时候, 只需要往加法器输入两个源操作数, 就能得到执行的结果了. 之后还要把结果写回到目的操作数中, 可能是寄存器, 也可能是内存.

## 更新PC
执行完一条指令之后, CPU就要执行下一条指令. 在这之前, CPU需要更新PC的值, 让PC加上刚才执行完的指令的长度, 即可指向下一条指令的位置.

于是, 计算机不断地重复上述四个步骤, 不断地执行指令, 直到永远.

## 运行第一个C程序
要使程序能够顺利运行起来，需要在NEMU中添加指令。通过反汇编的结果来查看缺少哪些指令，这些指令的操作码是什么，在inst.c中新增指令。  
```c
  INSTPAT_START();
  INSTPAT("??????? ????? ????? ??? ????? 00101 11", auipc, U, R(rd) = s->pc + imm);
  INSTPAT("??????? ????? ????? 100 ????? 00000 11", lbu, I, R(rd) = Mr(src1 + imm, 1));
  INSTPAT("??????? ????? ????? 000 ????? 01000 11", sb, S, Mw(src1 + imm, 1, src2));

/*-----dummy.c所需要的几个指令---*/
  INSTPAT("??????? ????? ????? 000 ????? 11001 11", ret, I, R(rd) = s->pc + 4; s->dnpc = (src1 + imm) & ~1); // jalr(ret)指令
  INSTPAT("??????? ????? ????? 000 ????? 00100 11", addi, I, R(rd) = src1 + imm);
  INSTPAT("??????? ????? ????? ??? ????? 11011 11", jal, J, R(rd) = s->pc + 4; s->dnpc += imm - 4;); // jal指令
  INSTPAT("??????? ????? ????? 010 ????? 01000 11", sw, S, Mw(src1 + imm, 4, src2));
/*----------------------------*/

  INSTPAT("0000000 00001 00000 000 00000 11100 11", ebreak, N, NEMUTRAP(s->pc, R(10))); // R(10) is $a0
  INSTPAT("??????? ????? ????? ??? ????? ????? ??", inv, N, INV(s->pc));

  INSTPAT_END();
```

一开始做的时候是一头雾水，因为反汇编的结果是16进制格式的，一开始没有什么头绪，
![PA2.1](/images/PA/PA2.1.png)