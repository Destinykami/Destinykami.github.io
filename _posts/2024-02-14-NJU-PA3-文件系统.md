---
title: '南京大学 PA3-文件系统'
date: 2024/02/14
permalink: /posts/2024/01/nju-pa-3-2
excerpt: '南京大学 计算机基础PA3 文件系统'
tags:
  - OS
---
## 文件系统
文件的本质就是字节序列, 另外还由一些额外的属性构成. 在这里, 我们先讨论普通意义上的文件. 这样, 那些额外的属性就维护了文件到ramdisk存储位置的映射. 为了管理这些映射, 同时向上层提供文件操作的接口, 我们需要在Nanos-lite中实现一个文件系统. 

我们对文件系统的需求并不是那么复杂, 因此我们可以定义一个简易文件系统sfs(Simple File System):

* 每个文件的大小是固定的
* 写文件时不允许超过原有文件的大小
* 文件的数量是固定的, 不能创建新文件
* 没有目录

既然文件的数量和大小都是固定的, 我们自然可以把每一个文件分别固定在ramdisk中的某一个位置. 这些简化的特性大大降低了文件系统的实现难度. 当然, 真实的文件系统远远比sfs复杂.

我们约定文件从ramdisk的最开始一个挨着一个地存放:
```
0
+-------------+---------+----------+-----------+--
|    file0    |  file1  |  ......  |   filen   |
+-------------+---------+----------+-----------+--
 \           / \       /            \         /
  +  size0  +   +size1+              + sizen +
```
为了记录ramdisk中各个文件的名字和大小, 我们还需要一张"文件记录表". Nanos-lite的Makefile提供了维护这些信息的脚本。

文件记录表"其实是一个数组, 数组的每个元素都是一个结构体:
```c
typedef struct {
  char *name;         // 文件名
  size_t size;        // 文件大小
  size_t disk_offset;  // 文件在ramdisk中的偏移

  size_t open_offset; //新增 偏移量

} Finfo;
```
在sfs中, 这三项信息都是固定不变的. 其中的文件名和我们平常使用的习惯不太一样: 由于sfs没有目录, 我们把目录分隔符/也认为是文件名的一部分, 例如/bin/hello是一个完整的文件名. 这种做法其实也隐含了目录的层次结构, 对于文件数量不多的情况, 这种做法既简单又奏效.

有了这些信息, 就已经可以实现最基本的文件读写操作了:
```c
size_t read(const char *filename, void *buf, size_t len);
size_t write(const char *filename, const void *buf, size_t len);
```
但在真实的操作系统中, 这种直接用文件名来作为读写操作参数的做法却有所缺陷.  

实际上, 操作系统中确实存在不少"没有名字"的文件. 为了统一管理它们, 我们希望通过一个编号来表示文件, 这个编号就是文件描述符(file descriptor). 一个文件描述符对应一个正在打开的文件, 由操作系统来维护文件描述符到具体文件的映射. 于是我们很自然地通过open()系统调用来打开一个文件, 并返回相应的文件描述符
```c
int open(const char *pathname, int flags, int mode);
```
在Nanos-lite中, 由于sfs的文件数目是固定的, 我们可以简单地把文件记录表的下标作为相应文件的文件描述符返回给用户程序. 在这以后, 所有文件操作都通过文件描述符来标识文件:
```c
size_t read(int fd, void *buf, size_t len);
size_t write(int fd, const void *buf, size_t len);
int close(int fd);
```
另外, 我们也不希望每次读写操作都需要从头开始. 于是我们需要为每一个已经打开的文件引入偏移量属性open_offset, 来记录目前文件操作的位置. 每次对文件读写了多少个字节, 偏移量就前进多少.

> **文件偏移量和用户程序**  
事实上，在真正的操作系统中, 把偏移量放在文件记录表中维护会导致用户程序无法实现某些功能. 但解释这个问题需要理解一些超出课程范围的知识, 我们在此就不展开叙述了. 你可以在学习操作系统课程的时候再来思考这个问题.  
由于Nanos-lite是一个精简版的操作系统, 上述问题暂时不会出现, 为了简化实现, 我们还是把偏移量放在文件记录表中进行维护.  
偏移量可以通过lseek()系统调用来调整, 从而可以对文件中的任意位置进行读写:  

```c
size_t lseek(int fd, size_t offset, int whence);
```
为了方便用户程序进行标准输入输出, 操作系统准备了三个默认的文件描述符:
```c
#define FD_STDIN 0  //标准输入stdin
#define FD_STDOUT 1 //标准输出stdout
#define FD_STDERR 2 //标准错误stderr
```
我们经常使用的`printf`, 最终会调用`write(FD_STDOUT, buf, len)`进行输出; 而`scanf`将会通过调用`read(FD_STDIN, buf, len)`进行读入.

nanos-lite/src/fs.c中定义的`file_table`会包含`nanos-lite/src/files.h`, 其中前面还有3个特殊的文件: stdin, stdout和stderr的占位表项, 它们只是为了保证sfs和约定的标准输入输出的文件描述符保持一致, 例如根据约定stdout的文件描述符是1, 而我们添加了三个占位表项之后, 文件记录表中的1号下标也就不会分配给其它的普通文件了.
```c
/* This is the information about all files in disk. */
static Finfo file_table[] __attribute__((used)) = {
  [FD_STDIN]  = {"stdin", 0, 0, invalid_read, invalid_write},
  [FD_STDOUT] = {"stdout", 0, 0, invalid_read, invalid_write},
  [FD_STDERR] = {"stderr", 0, 0, invalid_read, invalid_write},
#include "files.h"
};
```
根据以上信息, 我们就可以在文件系统中实现以下的文件操作了:
```c
int fs_open(const char *pathname, int flags, int mode);
size_t fs_read(int fd, void *buf, size_t len);
size_t fs_write(int fd, const void *buf, size_t len);
size_t fs_lseek(int fd, size_t offset, int whence);
int fs_close(int fd);
```
这些文件操作实际上是相应的系统调用在内核中的实现.  

------
## 实现这些系统调用
* fs_open

只需要遍历文件记录表，按照文件名返回下标即可。
```c
int fs_open(const char *pathname, int flags, int mode) {
    for (int i = 0; i < LENGTH(file_table); ++i) {
        if (strcmp(file_table[i].name, pathname) == 0) {
            file_table[i].open_offset=0;
            return i;
        }
    }
    panic("file %s not found", pathname); //文件不存在
    return -1;
}
```
* fs_close

  由于sfs没有维护文件打开的状态, fs_close()可以直接返回0, 表示总是关闭成功，同时把文件偏移量设为0.
```c
int fs_close(int fd){
  file_table[fd].open_offset=0;
  return 0;
}
```
* fs_read 

  其实就是对ramdisk_read的一层抽象。本质上是根据文件在磁盘上的偏移量，找到要读取的位置，调用ramdisk_read读取len字节。注意偏移量不要越过文件的边界.  
```c
size_t fs_read(int fd, void *buf, size_t len) {
    if (fd <= 2) {
        Log("ignore read %s", file_table[fd].name);
        return 0;
    }
    size_t read_len = len;
    size_t open_offset = file_table[fd].open_offset;
    size_t size = file_table[fd].size;
    size_t disk_offset = file_table[fd].disk_offset;

    if (open_offset > size) return 0; 
    if (open_offset + len > size) read_len = size - open_offset; //读取不能超过文件大小
    ramdisk_read(buf, disk_offset + open_offset, read_len);
    file_table[fd].open_offset += read_len;
    return read_len;
}
```
* fs_write

  和fs_read同理
```c
size_t fs_write(int fd, const void *buf, size_t len) {
    if (fd == 0) {
        Log("ignore write %s", file_table[fd].name);
        return 0;
    }

    if (fd == 1 || fd == 2) {
        for (size_t i = 0; i < len; ++i)
            putch(*((char *)buf + i));
        return len;
    }

    size_t write_len = len;
    size_t open_offset = file_table[fd].open_offset;
    size_t size = file_table[fd].size;
    size_t disk_offset = file_table[fd].disk_offset;

    if (open_offset > size) return 0;

    if (open_offset + len > size) write_len = size - open_offset;
    ramdisk_write(buf, disk_offset + open_offset, write_len);
    file_table[fd].open_offset += write_len;
    return write_len;
}
```
* fs_lseek
  * SEEK_SET:设置偏移量为offset
  * SEEK_CUR:设置偏移量为距离当前偏移量offset
  * SEEK_END:设置偏移量为距离为文件尾offset 
    > 这样不会偏到外面去吗?
```c
size_t fs_lseek(int fd, size_t offset, int whence) {
    if (fd <= 2) {
        Log("ignore lseek %s", file_table[fd].name);
        return 0;
    }
    size_t new_offset = -1;
    size_t size = file_table[fd].size;
    size_t open_offset = file_table[fd].open_offset;
    switch (whence) {
        case SEEK_SET:
            if (offset > size) new_offset = size;
            new_offset = offset;
            break;
        case SEEK_CUR:
            if (offset + open_offset > size) new_offset = size;
            new_offset = offset + open_offset;
            break;
        case SEEK_END:
            if (offset + size > size) new_offset = size;
            new_offset = offset + size;
            break;
        default:
            Log("Unknown whence %d", whence);
            return -1;
    }

    assert(new_offset >= 0);
    file_table[fd].open_offset = new_offset;
    return new_offset;
}
```
另外不要忘记在navy-apps/libs/libos/syscall.c中修改用户调用:  
```c
int _read(int fd, void *buf, size_t count) {
   return _syscall_(SYS_read, fd, (intptr_t)buf, count);
}

int _close(int fd) {
  return _syscall_(SYS_close,fd,0,0);
}

int _open(const char *path, int flags, mode_t mode) {
  return _syscall_(SYS_open,(intptr_t)path,0,0);
}

int _write(int fd, void *buf, size_t count) {
  return _syscall_(SYS_write, fd, (intptr_t)buf, count);
}

off_t _lseek(int fd, off_t offset, int whence) {
  return _syscall_(SYS_lseek,fd,(intptr_t) offset,whence);
}
```
## 让loader使用文件
我们之前是让loader来直接调用ramdisk_read()来加载用户程序. ramdisk中的文件数量增加之后, 这种方式就不合适了, 我们首先需要让loader享受到文件系统的便利.

实现以上的系统调用后就可以在loader中使用文件名来指定加载的程序了, 例如"/bin/hello".

以后更换用户程序只需要修改传入naive_uload()函数的文件名即可.
```c
//loader.c

//对fs_read的包装
static void read(int fd,void *buf,size_t offset,size_t len){
  fs_lseek(fd,offset,SEEK_SET);
  fs_read(fd,buf,len);
}
static uintptr_t loader(PCB *pcb, const char *filename)
{
  int fd=fs_open(filename,0,0);// 打开文件
  if(fd==-1){
    assert(0);//filename指向的文件不存在
  }
  Elf_Ehdr ehdr;//ELF_header
  //从偏移量0开始读取sizeof(Elf_Ehdr)字节的数据。
  //ramdisk_read(&ehdr, 0, sizeof(Elf_Ehdr));
  read(fd,&ehdr,0,sizeof(Elf_Ehdr));
  // 用于检查ELF文件的合法性    0x7f454c46  由于是小端序，所以要逆序
  assert((*(uint32_t *)ehdr.e_ident == 0x464c457f));
  Log("Load OK!");
  // 创建一个Elf_Phdr类型的数组phdr，用于存储ELF文件的程序头表信息。ehdr.e_phnum表示头部表的数量
  Elf_Phdr phdr[ehdr.e_phnum];
  // 使用ramdisk_read函数从ramdisk中读取程序头表信息。ehdr.e_ehsize指示了程序头表在文件中的偏移量，
  // sizeof(Elf_Phdr)*ehdr.e_phnum表示要读取的字节数，将所有程序头表都读取到数组phdr中。
  //ramdisk_read(phdr, ehdr.e_ehsize, sizeof(Elf_Phdr) * ehdr.e_phnum);
  read(fd,&phdr,ehdr.e_ehsize,sizeof(Elf_Phdr) * ehdr.e_phnum);

  for (size_t i = 0; i < ehdr.e_phnum; i++)
  {
    // 检查当前程序头表条目的类型是否为PT_LOAD，表示这是一个需要加载到内存中的段
    if (phdr[i].p_type == PT_LOAD)
    {
      // 使用ramdisk_read函数将当前段的内容从ramdisk中读取到内存中。phdr[i].p_vaddr表示段的虚拟地址，
      // phdr[i].p_offset表示段在文件中的偏移量，phdr[i].p_memsz表示段在内存中的大小。
      //ramdisk_read((void *)phdr[i].p_vaddr, phdr[i].p_offset, phdr[i].p_memsz);
      read(fd,(void *)phdr[i].p_vaddr,phdr[i].p_offset, phdr[i].p_memsz);
      // 如果段的文件大小小于内存大小，这个代码用于将未初始化部分（即.bss部分）填充为零。
      memset((void *)(phdr[i].p_vaddr + phdr[i].p_filesz), 0, phdr[i].p_memsz - phdr[i].p_filesz);
    }
  }
  // 返回ELF文件的入口地址，表示加载并准备执行的程序的入口点。
  return ehdr.e_entry;
}

//proc.c
  // load program here
  const char filename[] = "/bin/file-test";
  naive_uload(NULL, filename);
```
注意到这里还将fs_read和fs_seek包装为一个read函数。这样可以保证将程序正确的读到内存中。 

## 虚拟文件系统
为了实现一切皆文件的思想, 我们之前实现的文件操作就需要进行扩展了: 我们不仅需要对普通文件进行读写, 还需要支持各种"特殊文件"的操作. 至于扩展的方式, 就是抽象.

我们对之前实现的文件操作API的语义进行扩展, 让它们可以支持任意文件(包括"特殊文件")的操作:
```c
int fs_open(const char *pathname, int flags, int mode);
size_t fs_read(int fd, void *buf, size_t len);
size_t fs_write(int fd, const void *buf, size_t len);
size_t fs_lseek(int fd, size_t offset, int whence);
int fs_close(int fd);
```
这组扩展语义之后的API有一个酷炫的名字, 叫VFS(虚拟文件系统). 既然有虚拟文件系统, 那相应地也应该有"真实文件系统", 这里所谓的真实文件系统, 其实是指具体如何操作某一类文件. 比如在Nanos-lite上, 普通文件通过ramdisk的API进行操作; 在真实的操作系统上, 真实文件系统的种类更是数不胜数: 比如熟悉Windows的你应该知道管理普通文件的NTFS, 目前在GNU/Linux上比较流行的则是EXT4; 至于特殊文件的种类就更多了, 于是相应地有procfs, tmpfs, devfs, sysfs, initramfs... 这些不同的真实文件系统, 它们都分别实现了这些文件的具体操作方式.

所以, VFS其实是对不同种类的真实文件系统的抽象, 它用一组API来描述了这些真实文件系统的抽象行为, 屏蔽了真实文件系统之间的差异, 上层模块(比如系统调用处理函数)不必关心当前操作的文件具体是什么类型, 只要调用这一组API即可完成相应的文件操作. 有了VFS的概念, 要添加一个真实文件系统就非常容易了: 只要把真实文件系统的访问方式包装成VFS的API, 上层模块无需修改任何代码, 就能支持一个新的真实文件系统了.

在Nanos-lite中, 实现VFS的关键就是Finfo结构体中的两个读写函数指针:
```c
typedef struct {
  char *name;         // 文件名
  size_t size;        // 文件大小
  size_t disk_offset;  // 文件在ramdisk中的偏移
  ReadFn read;        // 读函数指针
  WriteFn write;      // 写函数指针
} Finfo;
```
其中ReadFn和WriteFn分别是两种函数指针, 它们用于指向真正进行读写的函数, 并返回成功读写的字节数. 有了这两个函数指针, 我们只需要在文件记录表中对不同的文件设置不同的读写函数, 就可以通过f->read()和f->write()的方式来调用具体的读写函数了.

不过在Nanos-lite中, 由于特殊文件的数量很少, 我们约定, 当上述的函数指针为NULL时, 表示相应文件是一个普通文件, 通过ramdisk的API来进行文件的读写, 这样我们就不需要为大多数的普通文件显式指定ramdisk的读写函数了.

我们把文件看成字节序列, 大部分字节序列都是"静止"的, 例如对于ramdisk和磁盘上的文件, 如果我们不对它们进行修改, 它们就会一直位于同一个地方, 这样的字节序列具有"位置"的概念; 但有一些特殊的字节序列并不是这样, 例如键入按键的字节序列是"流动"的, 被读出之后就不存在了, 这样的字节序列中的字节之间只有顺序关系, 但无法编号, 因此它们没有"位置"的概念. 属于前者的文件支持lseek操作, 存储这些文件的设备称为"块设备"; 而属于后者的文件则不支持lseek操作, 相应的设备称为"字符设备". 真实的操作系统还会对lseek操作进行抽象, 我们在Nanos-lite中进行了简化, 就不实现这一抽象了.

## 操作系统之上的IOE
有了VFS, 要把IOE抽象成文件就非常简单了.

首先当然是来看最简单的输出设备: 串口. 在Nanos-lite中, stdout和stderr都会输出到串口. 之前你可能会通过判断fd是否为1或2, 来决定sys_write()是否写入到串口. 现在有了VFS, 我们就不需要让系统调用处理函数关心这些特殊文件的情况了: 我们只需要在nanos-lite/src/device.c中实现serial_write(), 然后在文件记录表中设置相应的写函数, 就可以实现上述功能了. 由于串口是一个字符设备, 对应的字节序列没有"位置"的概念, 因此serial_write()中的offset参数可以忽略. 另外Nanos-lite也不打算支持stdin的读入, 因此在文件记录表中设置相应的报错函数即可.  

### 把串口抽象成文件  
根据上述内容, 让VFS支持串口的写入.
```c
//device.c
size_t serial_write(const void *buf, size_t offset, size_t len) {
  for (size_t i = 0; i < len; ++i)
    putch(*((char *)buf + i));
  return len;
}

//fs.c
/* This is the information about all files in disk. */
static Finfo file_table[] __attribute__((used)) = {
  [FD_STDIN]  = {"stdin", 0, 0, invalid_read, invalid_write},
  [FD_STDOUT] = {"stdout", 0, 0, invalid_read, serial_write}, 
  [FD_STDERR] = {"stderr", 0, 0, invalid_read, serial_write},
#include "files.h"
};
size_t fs_read(int fd, void *buf, size_t len) {
    ReadFn readFn = file_table[fd].read; //新增
    if (readFn != NULL) {
        return readFn(buf, 0, len);
    }

    size_t read_len = len;
    size_t open_offset = file_table[fd].open_offset;
    size_t size = file_table[fd].size;
    size_t disk_offset = file_table[fd].disk_offset;

    if (open_offset > size) return 0; 
    if (open_offset + len > size) read_len = size - open_offset; //读取不能超过文件大小
    ramdisk_read(buf, disk_offset + open_offset, read_len);
    file_table[fd].open_offset += read_len;
    return read_len;
}
size_t fs_write(int fd, const void *buf, size_t len) {
    WriteFn writeFn = file_table[fd].write; //新增
    if (writeFn != NULL) {
        return writeFn(buf, 0, len);
    }

    size_t write_len = len;
    size_t open_offset = file_table[fd].open_offset;
    size_t size = file_table[fd].size;
    size_t disk_offset = file_table[fd].disk_offset;

    if (open_offset > size) return 0;

    if (open_offset + len > size) write_len = size - open_offset;
    ramdisk_write(buf, disk_offset + open_offset, write_len);
    file_table[fd].open_offset += write_len;
    return write_len;
}
```
### 时钟
关于输入设备, 我们先来看看时钟. 时钟比较特殊, 大部分操作系统并没有把它抽象成一个文件, 而是直接提供一些和时钟相关的系统调用来给用户程序访问. 在Nanos-lite中, 我们也提供一个SYS_gettimeofday系统调用, 用户程序可以通过它读出当前的系统时间.  

**实现gettimeofday**  
实现gettimeofday系统调用, 实现后, 在navy-apps/tests/中新增一个timer-test测试, 在测试中通过gettimeofday()获取当前时间, 并每过0.5秒输出一句话.

```c
//用户调用
int _gettimeofday(struct timeval *tv, struct timezone *tz) {
  return _syscall_(SYS_gettimeofday,(intptr_t)tv,(intptr_t)tz,0);
}
//系统调用
int sys_gettimeofday(Context *c){
  //这里有个比较头疼的点，以tv和tz做参数时，由于不需要处理tz,导致会报错，所以直接传了个上下文来...
  struct timeval *tv=(struct timeval *)c->GPR2;
  time_t us=io_read(AM_TIMER_UPTIME).us;//从串口读取当前时间
  tv->tv_sec=us/100000;
  tv->tv_usec=us;
  return 0;
}
//测试程序
//time-test.c
#include <stdio.h>
#include <assert.h>
#include <sys/time.h>

int main() {
    struct timeval init;
    struct timeval now;

    assert(gettimeofday(&init, NULL) == 0);
    time_t init_sec = init.tv_sec;
    suseconds_t init_usec = init.tv_usec;

    size_t times = 1;

    while (1) {
        assert(gettimeofday(&now, NULL) == 0);
        time_t now_sec = now.tv_sec;
        suseconds_t now_usec = now.tv_usec;
        uint64_t time_gap = (now_sec - init_sec) * 1000000 + (now_usec - init_usec); // unit: us  注意不要出现浮点数的计算，因为nemu不支持浮点数
        if (time_gap > 500000 * times) {
            printf("Half a second passed, %u time(s)\n", times);
            times++;
        }
    }
}
```