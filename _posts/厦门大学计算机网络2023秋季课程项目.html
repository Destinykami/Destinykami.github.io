---
title: 'XMU-Computer Network'
date: 2024/1/18
permalink: /posts/2024/01/rCore_ch6/
excerpt: '第六章 文件系统'
tags:
  - rCore
  - OS
---

<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>厦门大学计算机网络2023秋季课程项目</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="2346e101-a05f-4b04-8c57-e5d0d065cc62" class="page serif"><header><img class="page-cover-image" src="https://www.notion.so/images/page-cover/nasa_earth_grid.jpg" style="object-position:center 30.000000000000004%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">🌐</span></div><h1 class="page-title">厦门大学计算机网络2023秋季课程项目</h1><p class="page-description"></p></header><div class="page-body"><hr id="1c461284-96db-4bd3-95ff-0aab20ff49de"/><h3 id="37d41347-6f36-47b6-b868-7d139ffea68a" class="block-color-default">厦门大学   计算机科学与技术系   郑程硕   22920212204312</h3><hr id="8f5e37f7-c6f4-4589-91c1-2faec195800f"/><h1 id="3a213a60-c1c7-4007-8bcd-a0a6ada8bb61" class="">TCP协议栈的构建与拓展观察</h1><h1 id="ebbeb7c7-9d93-4c7d-bbbe-f704efb7a80b" class="">简介</h1><p id="89e57aaf-7a2d-4c78-b42b-95409cb41eb0" class="">TCP（Transmission Control Protocol）是一种面向连接的、可靠的传输层协议，用于在网络上传输数据。TCP使用有限状态机（Finite State Machine，FSM）来描述其运行过程。有限状态机是一种数学模型，用于描述系统在不同状态之间的转换和行为。在TCP中，有限状态机描述了TCP连接的不同阶段和状态，以及在这些状态之间发生的转换。</p><figure id="485135e6-03e5-48e3-8abb-252a1d6e06a1" class="image"><a href="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled.png"><img style="width:528px" src="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled.png"/></a></figure><p id="cf2fa748-7802-4081-8a86-5997a786e54d" class="">这是RFC 9293中对于TCP有限状态机的简要描述，其精简了一些过程。</p><h1 id="6d7ef54c-8a99-45a1-99b5-73720b6844fa" class="">项目目标</h1><p id="cabbafbf-0cba-4805-85d9-52dbc60ad132" class="">现在，你已经在《计算机网络》课程上学习了计算机网络的基本工作原理以及所采用的技术，但还很难把这些理论知识与每天使用的网络联系起来，也不知道怎么解决生活中遇到的网络问题。这就是这个项目的意义：<br/>一方面，把抽象的协议用实际的代码实现起来，你会发现支撑网络的底层的协议，原来用代码这么容易就可以实现。<br/>另一方面，在这个过程中，你会利用网络调试工具，解决自己实现协议时出现的各种问题——这些解决方法可以迁移到日常的网络使用当中：未来当你再次遇到网络不通的时候，你可以用工具定位出具体的问题，自己尝试解决，而不是去盲目地重启，就不怕别人说：“你不是学计算机的吗，难道还不会修网络？”的问题。<br/></p><p id="5d9961f3-6545-49f1-b082-8f05e8971337" class="">在课程学习的TCP的知识之上，构建精简的TCP的有限状态机，其应该能够实现TCP的基本功能，包括可靠传输、拥塞控制、超时重传等。并使用构建出的TCP模块进行通信，使用wireshark抓包获取通信过程。此外将基于构建出的TCP模块进行拓展探究。</p><p id="90607f9f-9948-4c73-bd75-8431c45f910f" class="">本项目基于Stanford University CS144 2020 Fall 的实验指导书以及实验平台，并参阅RFC文档与《计算机网络-自顶向下方法》。由于完整的实验是一个非常庞大的过程，所以做了一些精简，只选择了关于TCP的部分(lab0-lab4)，其基本框架如下图所示。</p><figure id="b97eb51b-8906-4d5a-9e3f-3abab67e3330" class="image"><a href="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%201.png"><img style="width:912px" src="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%201.png"/></a></figure><p id="9a37d6b4-c90c-4e86-9fb2-438dd0cddab7" class="">总的来说，本项目将分为两大部分，前半部分将按照CS144的实验指导书来完成构建TCP协议栈的要求，后半部分将基于构建出来的TCP协议栈进行探究，探究内容包括零窗口问题已经CS144中缺失的TCP拥塞控制部分。</p><h1 id="2794bc81-be96-4f16-aba5-5be23d7115a3" class="">TCP Header</h1><p id="18c15d88-ea86-4412-9835-e9bd385d11da" class="">这是所要用到的TCP首部的数据结构设计，来自<strong>RFC 9293</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="60190852-75c3-48ca-a702-30fa2fddadf4" class="code"><code class="language-C++">struct TCPHeader {
    static constexpr size_t LENGTH = 20; 
    //!   0                   1                   2                   3
    //!   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //!  |          Source Port          |       Destination Port        |
    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //!  |                        Sequence Number                        |
    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //!  |                    Acknowledgment Number                      |
    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //!  |  Data |           |U|A|P|R|S|F|                               |
    //!  | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
    //!  |       |           |G|K|H|T|N|N|                               |
    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //!  |           Checksum            |         Urgent Pointer        |
    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //!  |                    Options                    |    Padding    |
    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    //!  |                             data                              |
    //!  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    uint16_t sport = 0;         //!&lt; source port
    uint16_t dport = 0;         //!&lt; destination port
    WrappingInt32 seqno{0};     //!&lt; sequence number
    WrappingInt32 ackno{0};     //!&lt; ack number
    uint8_t doff = LENGTH / 4;  //!&lt; data offset
    bool urg = false;           //!&lt; urgent flag
    bool ack = false;           //!&lt; ack flag
    bool psh = false;           //!&lt; push flag
    bool rst = false;           //!&lt; rst flag
    bool syn = false;           //!&lt; syn flag
    bool fin = false;           //!&lt; fin flag
    uint16_t win = 0;           //!&lt; window size
    uint16_t cksum = 0;         //!&lt; checksum
    uint16_t uptr = 0;          //!&lt; urgent pointer
};</code></pre><h1 id="47aa9862-a0c1-4014-98f6-cba26f1f0e00" class="">TCP Receiver</h1><p id="540f0ba9-be40-411a-a7d7-582000241b22" class="">这是TCP的接收方，其要完成的工作是将读入的数据写入至 ByteStream 中，以及告知TCP发送方它的<strong>接收窗口的大小</strong>以及<strong>下一个期望接收到的报文的序号</strong>。在wireshark抓包中显示为 ack \ win。</p><figure id="5ddafabd-e133-4d01-bd50-259ad9eab891" class="image"><a href="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%202.png"><img style="width:1553px" src="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%202.png"/></a></figure><p id="73704e9e-6fcb-4d98-a5dc-2919fc507759" class="">需要实现一些类成员函数：</p><ul id="91228810-fe71-45ee-9488-97ed348ec4c0" class="bulleted-list"><li style="list-style-type:disc">segment_received(): 该函数将会在每次获取到 TCP 报文时被调用。如果接收到了 SYN 包，则设置 ISN 编号。将获取到的数据传入流重组器，并在接收到 FIN 包时终止数据传输。</li></ul><ul id="860be36a-2a03-4b1a-b5eb-3963ac20e85b" class="bulleted-list"><li style="list-style-type:disc">ackno()：返回接收方尚未获取到的第一个字节的字节索引。如果 ISN 暂未被设置，则返回空。</li></ul><ul id="312ecefe-5900-436f-9fbc-0fe6ed01ca10" class="bulleted-list"><li style="list-style-type:disc">window_size()：返回接收窗口的大小，即第一个未组装的字节索引和第一个不可接受的字节索引之间的长度。</li></ul><p id="64f71884-06f8-466b-85e4-2c805d4dd697" class="">初始状态：</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="58236e38-8104-440f-a003-9606134cfdf1" class="code"><code class="language-C++">#include &quot;tcp_receiver.hh&quot;

// Dummy implementation of a TCP receiver

// For Lab 2, please replace with a real implementation that passes the
// automated checks run by `make check_lab2`.

template &lt;typename... Targs&gt;
void DUMMY_CODE(Targs &amp;&amp;... /* unused */) {}

using namespace std;

bool TCPReceiver::segment_received(const TCPSegment &amp;seg) {
    DUMMY_CODE(seg);
    return {};
}

optional&lt;WrappingInt32&gt; TCPReceiver::ackno() const { return {}; }

size_t TCPReceiver::window_size() const { return {}; }</code></pre><p id="a8580027-9cbd-4ce5-9bdd-b6adda07d225" class="">在实验指导书中给出了TCP Receiver在生命周期中的演变过程图：</p><figure id="9dd291eb-ded8-469e-866a-1b67d07f93f3" class="image"><a href="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%203.png"><img style="width:816px" src="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%203.png"/></a></figure><h3 id="94cd8732-b075-4e2a-b78d-800a17c596a8" class="">接收方对于接收报文的判断逻辑</h3><ul id="2ec15e16-4ee6-4da1-aef3-c6401617b66f" class="bulleted-list"><li style="list-style-type:disc">如果不是在SYN-RECV状态<ul id="debca271-f0f6-4beb-a18e-49c222b30ef2" class="bulleted-list"><li style="list-style-type:circle">收到的报文含syn字段，表示有新的连接请求，此时进入SYN-RECV状态，即SYN_flag 被设置为 1，记录初始序列号 _isn，并初始化基序号 _base 为 1。如果该 SYN 报文是空的（即只包含 SYN 字段），则不执行后续操作。</li></ul><ul id="4d238b03-4383-4b53-bd45-6883f8eb9bd0" class="bulleted-list"><li style="list-style-type:circle">收到的报文不含syn字段，说明在未建立连接状态下收到了非 SYN 报文，这种情况下应该丢弃该报文。</li></ul></li></ul><ul id="f776d8ed-27d5-4779-94ef-e16408f67606" class="bulleted-list"><li style="list-style-type:disc">如果已经在SYN-RECV状态<ul id="1094be27-e6f1-448e-b3a6-be79ba8599b6" class="bulleted-list"><li style="list-style-type:circle">收到的报文含syn字段，丢弃报文。</li></ul><ul id="2ab10f53-c81d-47b3-a096-741ce1238ba5" class="bulleted-list"><li style="list-style-type:circle">收到的报文不含syn字段，说明是已建立连接下的普通数据报文。在这种情况下，处理已建立连接的数据报文。将报文的有效部分添加到缓冲区 _reassembler 中，通过解封装计算绝对序列号 abs_seqno。处理可能存在的 FIN 字段，并根据报文的序列号和长度判断是否在窗口范围内。如果在窗口范围内，则继续处理；否则丢弃该报文。 </li></ul></li></ul><h3 id="17dd3b28-bb11-4027-9d86-a96a31edbdf8" class="">缓冲区处理 </h3><p id="d73a2f7e-081b-404d-b56d-31c3cc88c8f3" class="">TCPReceiver 使用 _reassembler 缓冲区来保存接收到的有效数据部分。以下是相关的行为：</p><p id="e5a9771e-b9c5-4bba-a867-473300e70580" class="">将有效部分添加到缓冲区： 通过调用 _reassembler.push_substring 方法，将报文的有效部分添加到缓冲区中，维护相应的绝对序列号 abs_seqno。</p><p id="312f1cd3-5f38-4061-a668-c95435cc0ae5" class="">更新基序号 _base： 根据缓冲区的头部索引，更新基序号 _base，以便后续的窗口范围判断。</p><p id="af9594e4-0c4c-4ed2-b029-7907b75b650c" class="">处理输入结束情况： 如果缓冲区的输入结束，即 _reassembler.input_ended() 返回 true，则更新基序号 _base，因为 FIN 字段被视为一个字节。</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8c042034-7eb3-427f-a141-1d5f18f8251c" class="code"><code class="language-C++">#include &quot;tcp_receiver.hh&quot;
// For Lab 2, please replace with a real implementation that passes the
// automated checks run by `make check_lab2`.
using namespace std;
bool TCPReceiver::segment_received(const TCPSegment &amp;seg) {
    static size_t abs_seqno = 0;
    size_t length;
    // 如果连接已建立
    if (SYN_flag == 1) {
        if (seg.header().syn) {
            return false;  // 已建立连接时不应该再收到SYN报文
        }
        // 处理已建立连接的报文
        abs_seqno = unwrap(WrappingInt32(seg.header().seqno.raw_value()), WrappingInt32(_isn), abs_seqno);
        length = seg.length_in_sequence_space();
        if (seg.header().fin) {
            if (FIN_flag == 1) {
                return false;  // 已经收到过FIN报文，不应再收到
            } else {
                FIN_flag = 1;
            }
        } else {
            if (seg.length_in_sequence_space() == 0 &amp;&amp; abs_seqno == _base) {
                return true;  // 收到空的报文，直接返回
            } else if (abs_seqno &gt;= _base + window_size() || abs_seqno + length &lt;= _base) {
                return false;  // 报文不在窗口范围内，丢弃
            }
        }
    } else  
    {   // 还未进入SYN-RECV
        if (!seg.header().syn) {
            return false;  // 还未建立连接，且收到的不是SYN报文
        }
        SYN_flag = 1;
        _isn = seg.header().seqno.raw_value();
        abs_seqno = 1;
        _base = 1;
        length = seg.length_in_sequence_space() - 1;
        if (length == 0) {
            return true;  // 空的SYN报文，直接返回
        }
    }
    // 将报文的有效部分添加到缓冲区中
    _reassembler.push_substring(seg.payload().copy(), abs_seqno - 1, seg.header().fin);
    _base = _reassembler.head_index() + 1;
    if (_reassembler.input_ended()) {
        _base++;  // FIN被视为一个字节
    }
    return true;
}

optional&lt;WrappingInt32&gt; TCPReceiver::ackno() const {
    if (_base &gt; 0)
        return WrappingInt32(wrap(_base, WrappingInt32(_isn)));
    else
        return std::nullopt;
}
size_t TCPReceiver::window_size() const { 
		return _capacity - _reassembler.stream_out().buffer_size(); 
}</code></pre><h3 id="049c7a98-e630-41f1-89f3-0af9e640ae62" class="">总结TCP Receiver</h3><p id="c950efdd-f4e7-48be-b39c-e6c2b8064db8" class="">为了减小任务量，把底层较为复杂的字节流重组逻辑黑箱化，使用底层提供的接口，着重对于接收到的TCP片段的处理，然后整个构建流程就是几个if的嵌套跳转。</p><h1 id="61adeb8f-d6ef-49ff-a80c-773df3568b57" class="">TCP Sender</h1><p id="eb126699-4cf3-42c5-9ceb-9781c6fc9c04" class="">TCP的许多重要特性在这里实现。</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="a098b0f5-28a5-49ce-a685-3d457340437b"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">这是实验指导书对本模块的要求：<p id="379afd9b-9b2e-4377-a2cf-1bb574ca56bf" class="">It will be your TCPSender’s responsibility to:</p><ul id="962f24cf-4676-4b11-ae1e-cbd74f0365d3" class="bulleted-list"><li style="list-style-type:disc">Keep track of the receiver’s window (processing incoming acknos and window sizes)</li></ul><ul id="336b6710-0cd8-496e-87c0-be98d5342dae" class="bulleted-list"><li style="list-style-type:disc">Fill the window when possible, by reading from the ByteStream, creating new TCP segments (including SYN and FIN flags if needed), and sending them. The sender should keep sending segments until either the window is full or the ByteStream is empty.</li></ul><ul id="e445d728-b31d-4bd6-b1a2-9547f223d5b5" class="bulleted-list"><li style="list-style-type:disc">Keep track of which segments have been sent but not yet acknowledged by the receiver — we call these “outstanding&quot; segments</li></ul><ul id="4874fa2c-0e70-4199-9b37-41a3c1d49f6e" class="bulleted-list"><li style="list-style-type:disc">Re-send outstanding segments if enough time passes since they were sent, and they haven’t been acknowledged yet.</li></ul><p id="0b0e8114-0ee2-4b28-8870-db6a711c1b84" class="">Why am I doing this? The basic principle is to send whatever the receiver will allow us to send (filling the window), and keep retransmitting until the receiver acknowledges each segment. This is called “<strong>automatic repeat request&quot; (ARQ).</strong> The sender divides the byte stream up into segments and sends them, as much as the receiver’s window allows. Thanks to your work last week, we know that the remote TCP receiver can reconstruct the byte stream as long as it receives each index-tagged byte at least once|no matter the order. The sender’s job is to make sure the receiver gets each byte at least once.</p></div></figure><p id="8792db4b-040a-4da9-b4d3-88ae5f31b214" class="">需要用到的几个函数：</p><ul id="ee2259a9-a1a6-448b-9f30-ca5c3bed3aa0" class="bulleted-list"><li style="list-style-type:disc">fill_window：TCPSender 从 ByteStream 中读取数据，并以 TCPSegement 的形式发送，尽可能地填充接收者的窗口。</li></ul><ul id="0cc7aa8d-1924-44ba-af0c-ec36ab46a245" class="bulleted-list"><li style="list-style-type:disc">ack_received：对接收方返回的 ackno 和 window size 进行处理。丢弃那些已经完全确认但仍然处于追踪队列的数据包。同时如果 window size 仍然存在空闲，则继续发包。</li></ul><ul id="db4732cc-0432-472f-ac53-6d41bbdb5c49" class="bulleted-list"><li style="list-style-type:disc">tick：该函数将会被调用以指示经过的时间长度。发送方可能需要重新发送一些超时且没有被确认的数据包。</li></ul><ul id="4d9abd3f-6fa7-45e6-8e9f-bc1d0c67fe22" class="bulleted-list"><li style="list-style-type:disc">send_empty_segment：生成并发送一个在 seq 空间中长度为 0 并正确设置 seqno 的 TCPSegment，这可让用户发送一个空的 ACK 段。</li></ul><p id="4bc109c7-53f1-4cd5-9012-a3af4749fdb3" class="">初始状态：</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1029788b-52c1-4581-9862-39df24e476d0" class="code"><code class="language-C++">#include &quot;tcp_sender.hh&quot;
#include &quot;tcp_config.hh&quot;
#include &lt;random&gt;
// Dummy implementation of a TCP sender
// For Lab 3, please replace with a real implementation that passes the
// automated checks run by `make check_lab3`.
template &lt;typename... Targs&gt;
void DUMMY_CODE(Targs &amp;&amp;... /* unused */) {}
using namespace std;

//! \param[in] capacity the capacity of the outgoing byte stream
//! \param[in] retx_timeout the initial amount of time to wait before retransmitting the oldest outstanding segment
//! \param[in] fixed_isn the Initial Sequence Number to use, if set (otherwise uses a random ISN)
TCPSender::TCPSender(const size_t capacity, const uint16_t retx_timeout, const std::optional&lt;WrappingInt32&gt; fixed_isn)
    : _isn(fixed_isn.value_or(WrappingInt32{random_device()()}))
    , _initial_retransmission_timeout{retx_timeout}
    , _stream(capacity) {}

uint64_t TCPSender::bytes_in_flight() const { return {}; }

void TCPSender::fill_window() {}

//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)
//! \param window_size The remote receiver&#x27;s advertised window size
//! \returns `false` if the ackno appears invalid (acknowledges something the TCPSender hasn&#x27;t sent yet)
bool TCPSender::ack_received(const WrappingInt32 ackno, const uint16_t window_size) {
    DUMMY_CODE(ackno, window_size);
    return {};
}
//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method
void TCPSender::tick(const size_t ms_since_last_tick) { DUMMY_CODE(ms_since_last_tick); }
unsigned int TCPSender::consecutive_retransmissions() const { return {}; }
void TCPSender::send_empty_segment() {}</code></pre><p id="8d566045-c899-4c04-9ba4-9ac0facac576" class="">下面将分模块进行构建：</p><h3 id="90de8e27-cd73-427f-931b-bcb90799fe3f" class="">超时重传</h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="0103cfee-5177-4029-93a8-66a84d2294ac"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">RFC 6298中提到：<p id="c277a520-a549-484e-a1a3-f078c5a68e25" class="">When the retransmission timer expires, do the following:</p><p id="0e93e509-415f-45e1-a325-542e798d9388" class="">(5.4) Retransmit the earliest segment that has not been acknowledged by the TCP receiver.</p><p id="d6a0d04e-f729-4edb-a4c1-625ec76c7016" class="">(5.5) The host MUST set RTO &lt;- RTO * 2 (&quot;back off the timer&quot;). The maximum value discussed in (2.5) above may be used to provide an upper bound to this doubling operation.</p><p id="342ead6a-243b-4298-b4c1-5604a38438b0" class="">(5.6) Start the retransmission timer, such that it expires after RTO seconds (for the value of RTO after the doubling operation outlined in 5.5).</p></div></figure><p id="117f6073-90ae-4b04-9c6b-292ad32d5f7a" class="">即需要创建计时器Timer,记录报文发出后经历的时间，如果时间超过设置好的RTO，就说明TCP发送超时，这时就重新发送该报文，并执行<strong>指数退避</strong>，即使RTO变为原来2倍。 </p><p id="adf84aed-41aa-4e8f-a1a0-d0330eedb9c8" class="">代码如下：</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="ea1252ea-147d-48d8-af14-293c948784c8" class="code"><code class="language-C++">void TCPSender::tick(const size_t ms_since_last_tick)  // 超时重传
{
    timer += ms_since_last_tick;
    if (timer &gt;= retransmission_timeout &amp;&amp; !SegmentsBuffer.empty())  // 发现超时
    {
        _segments_out.push(SegmentsBuffer.front());  // 重新发送报文
        retransmission_timeout *= 2;                 // 指数回退
        consecutive_retransmission++;                // 记录连续重传的次数
        timer_running = true;
        timer = 0;  // 重新计时
    }
    if (SegmentsBuffer.empty())  // 发送完毕,关闭定时器
    {
        timer = 0;
        timer_running = false;
    }
}</code></pre><h3 id="eaaff2a1-76ce-453a-9733-18f04cff56b7" class="">到达确认</h3><p id="ca68c6a0-8c65-4865-b2d5-b5f4fbc29e21" class="">接收端接收到分片数据时,根据分片数据序号向发送端发送一个确认,发送方会收到这个确认，并判断是否接受这个确认。</p><p id="19acff21-f5e2-46bc-b290-b7955758172f" class="">有以下两种情况： </p><ul id="37b1ca8e-37ff-4fc4-abad-924f203ea801" class="bulleted-list"><li style="list-style-type:disc">1.收到的ACK大于期望收到的ACK，这时就丢弃这个确认，退出该函数 </li></ul><ul id="7246c05f-280d-4089-a579-5d181d46f996" class="bulleted-list"><li style="list-style-type:disc">2.收到的ACK小于期望收到的ACK，这时说明在收到的ACK标号之前的报文都正确被接收方接收了，此时发送方执行对发送缓存的清理操作，将发送窗口设置为接收窗口的大小，初始化RTO，对连续重传的计数器进行清零。</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="cf17cb2b-315e-4430-8e8d-e5703b7ca04d" class="code"><code class="language-C++">bool TCPSender::ack_received(const WrappingInt32 ackno, const uint16_t window_size) {
    size_t abs_ackno = unwrap(ackno, _isn, recv_ackno);
    if (abs_ackno &gt; _next_seqno)  // 收到的ack比要期待接收的ack还大
    {
        return false;
    }
    if (abs_ackno &lt;= recv_ackno) { //收到的ack比要已经接收过的ack还小,说明可能是迟到的确认
        return true;
    }
    recv_ackno = abs_ackno;
    // 收到了当前ack,说明当前ack之前的报文已经全部收到了,从发送缓存中弹出
    while (!SegmentsBuffer.empty()) {
        TCPSegment seg = SegmentsBuffer.front();
        if (unwrap(seg.header().seqno, _isn, _next_seqno) + seg.length_in_sequence_space() &lt;= abs_ackno) {
            _bytes_in_flight -= seg.length_in_sequence_space();
            SegmentsBuffer.pop();
        } else
            break;
    }
    _window_size = window_size; //根据接收方的窗口来调整发送窗口
    retransmission_timeout = _initial_retransmission_timeout;  // 重置RTO
    consecutive_retransmission = 0;//重传次数归零
    fill_window();
    if (!SegmentsBuffer.empty()) {
        timer_running = true;
        timer = 0;
    }
    return true;
}</code></pre><h3 id="fa65d7b8-1647-4971-94a3-4fc3fcf423d6" class="">滑动窗口</h3><p id="a6252420-86a5-451f-ab78-84cc314a3a2c" class="">在TCPSender和TCPReceiver都维护一个窗口，分别为发送窗口和接收窗口。</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="cf4dece4-932d-4578-a4ca-118c580f8037" class="code"><code class="language-C++">void TCPSender::fill_window(bool send_syn) {
    if (!SYN_flag) {
        if (send_syn) {
            TCPSegment seg;
            seg.header().syn = true;
            send_segment(seg);
            SYN_flag = true;
        }
        return;
    }
    // 设置当前发送窗口的大小
    size_t current_window_size = 0;
    if (_window_size == 0)  // 如果接收方的窗口大小为0,则设置发送窗口大小为1,发送片段来判断接收方窗口是否打开
    {
        current_window_size = 1;
    } else
        current_window_size = _window_size;
    size_t remain = current_window_size - (_next_seqno - recv_ackno);  // 发送窗口剩余大小
    while ((remain = current_window_size - (_next_seqno - recv_ackno)) != 0 &amp;&amp; !FIN_flag) {
        size_t size = min(TCPConfig::MAX_PAYLOAD_SIZE, remain);  // 设置发送载荷大小
        TCPSegment seg;
        string str = _stream.read(size);  // 从字节流获取size大小的字符串
        seg.payload() = Buffer(move(str));
        // 当输入字节流到达eof且窗口未填满，可设置发送FIN
        if (seg.length_in_sequence_space() &lt; current_window_size &amp;&amp; _stream.eof()) {
            seg.header().fin = true;
            FIN_flag = true;
        }
        if (seg.length_in_sequence_space() == 0)  // 如果没有任何数据，则停止数据包的发送
            return;
        send_segment(seg);
    }
}</code></pre><p id="3d8e7e71-aebc-4c89-be48-74069596fc3b" class=""><strong>关于零窗口问题以及拥塞控制将放到最后讨论。</strong></p><p id="d2c12e26-d786-4cb8-ac90-41ee0957a3a5" class="">实验指导书上的TCP Sender的生命周期：</p><figure id="ee32d479-60bb-4e07-b99a-ed200f08e1ce" class="image"><a href="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%204.png"><img style="width:720px" src="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%204.png"/></a></figure><p id="d028d64b-cabb-4fd6-b978-2f8ae311ecaf" class="">
</p><h3 id="2f6d9c3b-8cf0-4c68-bc0b-8f1e166614b3" class="">一些变量</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2fcf8109-b4d8-4bf7-9137-136fad5ac6f6" class="code"><code class="language-C++">class TCPSender {
  private:
    //! our initial sequence number, the number for our SYN.
    WrappingInt32 _isn;
    //! outbound queue of segments that the TCPSender wants sent
    std::queue&lt;TCPSegment&gt; _segments_out{};
    //! retransmission timer for the connection
    unsigned int _initial_retransmission_timeout;//初始的RTO
    bool SYN_flag=false; //是否已经发送过SYN
    bool FIN_flag=false; //是否已经发送过FIN 
    size_t _window_size=0; //发送窗口大小
    size_t recv_ackno=0; //最近一次收到的ack
    uint64_t _bytes_in_flight = 0;
    size_t timer=0; //计时器
    bool timer_running=false;//计时器是否开始工作
    size_t retransmission_timeout;//当前的RTO
    size_t consecutive_retransmission=0;//连续重传的数目
    std::queue&lt;TCPSegment&gt; SegmentsBuffer{};//等待发送的片段
		........
}</code></pre><h1 id="976e624e-947d-4a4e-a618-f87786c27bc7" class="">TCP Connection</h1><p id="5f0da6f5-bf5d-453f-8461-4c71543d1efc" class="">TCPConnection 需要将 TCPSender 和 TCPReceiver 结合，实现成一个 TCP 终端，同时收发数据。</p><p id="5bc7d4d5-0d1e-414e-824f-ffe3f78f28b8" class="">是一个相当折磨的过程。因为之前的TCP Sender和TCP Receiver的测试样例并不够全面，设计的时候鲁棒性相当的差，所以在将他们连接起来后会出现各种问题，到处缝缝补补修理bug。</p><figure id="88687cb4-08b8-43f2-8275-641bab5a2647" class="image"><a href="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%205.png"><img style="width:816px" src="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%205.png"/></a></figure><p id="d54887a4-ed38-4298-bd92-bb5a7aeb30b8" class=""><strong>TCP协议栈由接收器和发送器组成,TCP连接生命周期所有状态如下面case枚举的状态所示：</strong></p><p id="dbe65141-c92d-41f0-96a0-9cf4f93b9781" class=""><strong>每个状态由一组接收器和发送器状态组成</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1accf33b-c875-4d9b-ba5e-d953452657a2" class="code"><code class="language-C++">TCPState::TCPState(const TCPState::State state) {
    switch (state) {
        case TCPState::State::LISTEN:
            _receiver = TCPReceiverStateSummary::LISTEN;
            _sender = TCPSenderStateSummary::CLOSED;
            break;
        case TCPState::State::SYN_RCVD:
            _receiver = TCPReceiverStateSummary::SYN_RECV;
            _sender = TCPSenderStateSummary::SYN_SENT;
            break;
        case TCPState::State::SYN_SENT:
            _receiver = TCPReceiverStateSummary::LISTEN;
            _sender = TCPSenderStateSummary::SYN_SENT;
            break;
        case TCPState::State::ESTABLISHED:
            _receiver = TCPReceiverStateSummary::SYN_RECV;
            _sender = TCPSenderStateSummary::SYN_ACKED;
            break;
        case TCPState::State::CLOSE_WAIT:
            _receiver = TCPReceiverStateSummary::FIN_RECV;
            _sender = TCPSenderStateSummary::SYN_ACKED;
            _linger_after_streams_finish = false;
            break;
        case TCPState::State::LAST_ACK:
            _receiver = TCPReceiverStateSummary::FIN_RECV;
            _sender = TCPSenderStateSummary::FIN_SENT;
            _linger_after_streams_finish = false;
            break;
        case TCPState::State::CLOSING:
            _receiver = TCPReceiverStateSummary::FIN_RECV;
            _sender = TCPSenderStateSummary::FIN_SENT;
            break;
        case TCPState::State::FIN_WAIT_1:
            _receiver = TCPReceiverStateSummary::SYN_RECV;
            _sender = TCPSenderStateSummary::FIN_SENT;
            break;
        case TCPState::State::FIN_WAIT_2:
            _receiver = TCPReceiverStateSummary::SYN_RECV;
            _sender = TCPSenderStateSummary::FIN_ACKED;
            break;
        case TCPState::State::TIME_WAIT:
            _receiver = TCPReceiverStateSummary::FIN_RECV;
            _sender = TCPSenderStateSummary::FIN_ACKED;
            break;
        case TCPState::State::RESET:
            _receiver = TCPReceiverStateSummary::ERROR;
            _sender = TCPSenderStateSummary::ERROR;
            _linger_after_streams_finish = false;
            _active = false;
            break;
        case TCPState::State::CLOSED:
            _receiver = TCPReceiverStateSummary::FIN_RECV;
            _sender = TCPSenderStateSummary::FIN_ACKED;
            _linger_after_streams_finish = false;
            _active = false;
            break;
    }
}</code></pre><p id="40984c39-a9fc-456a-8693-736b672a0bad" class="">TCPConnection 有几个规则需要遵守：</p><p id="30c1106f-5c62-4b0e-9f69-06212cdfb087" class="">对于接收数据端而言：</p><ul id="e14b64a6-6b52-4023-ac20-1368b75541e4" class="bulleted-list"><li style="list-style-type:disc">如果接收到的数据包设置了 RST 标志，则将输入输出字节流全部设置为 错误 状态，并永久关闭 TCP 连接。</li></ul><ul id="493d4936-0bf4-48e4-8eb6-cafefae71423" class="bulleted-list"><li style="list-style-type:disc">如果没有收到 RST 标志，则将该数据包传达给 TCPReceiver 来处理，它将对数据包中的 seqno、SYN、payload、FIN 进行处理。</li></ul><ul id="7f1735ac-a5b6-441d-9218-bc9cccf7b89e" class="bulleted-list"><li style="list-style-type:disc">如果接收到的数据包中设置了 ACK 标志，则向当前 TCPConnection 中它自己的 TCPSender 告知远程终端的 ackno 和 window_size。</li></ul><ul id="7c636992-f49a-4d95-b4ff-9c23d2bb55a1" class="bulleted-list"><li style="list-style-type:disc">如果接收到的 TCP 数据包包含了一个有效 seqno，则 TCPConnection 必须至少返回一个 TCP 包作为回复，以告知远程终端 此时的 ackno 和 window size。</li></ul><ul id="c1b1538e-4d91-4cfc-885f-8deedb20715a" class="bulleted-list"><li style="list-style-type:disc">如果接收到的 TCP 数据包包含的 seqno 是无效的，则 TCPConnection 也需要回复一个无效数据包。这是因为远程终端可能会发送无效数据包以确认当前连接是否有效，同时查看此时接收方的 ackno 和 window size。这被称为 TCP 的 keep-alive机制。</li></ul><p id="1dc89066-2755-46c0-bf28-d105de446dac" class="">对于发送数据端来说：</p><ul id="acf57c04-88b7-4fd9-9072-692af47385c3" class="bulleted-list"><li style="list-style-type:disc">当 TCPSender 将一个 TCPSegment 数据包添加到待发送队列中时，TCPConnection 需要从中取出并将其发送。</li></ul><ul id="c7b398d8-cabb-45ef-8a9c-3263b304d424" class="bulleted-list"><li style="list-style-type:disc">在发送当前数据包之前，TCPConnection 会获取当前它自己的 TCPReceiver 的 ackno 和 window size，将其放置进待发送 TCPSegment 中，并设置其 ACK 标志。</li></ul><p id="4a967134-71b3-4b99-92f9-0d0f53d3dc52" class="">当 TCPConnection 的 tick 函数被调用后，它需要</p><ul id="27bcc0cf-4f56-4022-a176-ff00f548cdcf" class="bulleted-list"><li style="list-style-type:disc">告知 TCPSender 时间的流逝，这可能会让 TCPSender 重新发送被丢弃的数据包</li></ul><ul id="f341e21c-19ac-4aea-8091-f00cbc56b1d0" class="bulleted-list"><li style="list-style-type:disc">如果连续重传次数超过 TCPConfig::MAX RETX ATTEMPTS，则发送一个 RST 包。</li></ul><ul id="9ad66594-c154-4843-9e5a-89e227162a68" class="bulleted-list"><li style="list-style-type:disc">在条件适合的情况下关闭 TCP 连接（当处于 TCP 的 TIME_WAIT 状态时）。<br/><br/></li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="666e2a12-59eb-403a-9366-cd76d209a39d" class="code"><code class="language-C++">#include &quot;tcp_connection.hh&quot;
#include &lt;iostream&gt;
// For Lab 4, please replace with a real implementation that passes the
// automated checks run by `make check`.
using namespace std;
// 发送窗口剩余空间
size_t TCPConnection::remaining_outbound_capacity() const { return _sender.stream_in().remaining_capacity(); }
// 已发送，但是还未收到ack的字节数
size_t TCPConnection::bytes_in_flight() const { return _sender.bytes_in_flight(); }
// 未按序到达的字节数
size_t TCPConnection::unassembled_bytes() const { return _receiver.unassembled_bytes(); }
// 上一次收到报文经过的时间
size_t TCPConnection::time_since_last_segment_received() const { return _time_since_last_segment_received; }
// 当前TCP是否还active
bool TCPConnection::active() const { return _active; }
// 接收TCP数据报
void TCPConnection::segment_received(const TCPSegment &amp;seg) {
    if (!_active)
        return;
    _time_since_last_segment_received = 0;
    //收到RST直接异常终止
    if (seg.header().rst) {
        unclean_shutdown(false);
        return;
    }
    //SYN_SENT状态不能收到带有数据载荷的ack
    if (TCPState::state_summary(_sender) == TCPSenderStateSummary::SYN_SENT 
        &amp;&amp; seg.header().ack &amp;&amp; seg.payload().size() &gt; 0) 
    {
        return;
    }
    bool send_empty = false;
    //收到ACK包，更新sender的状态
    if (_sender.next_seqno_absolute() &gt; 0 &amp;&amp; seg.header().ack) {
        if (!_sender.ack_received(seg.header().ackno, seg.header().win)) {
            send_empty = true;
        }
    }
    //接收方接收报文
    bool recv_flag = _receiver.segment_received(seg);
    if (!recv_flag) {
        send_empty = true;
    }
    // 接收器初次接收到SYN包,并且此时发送器还处于关闭状态,所以当前由LISTEN转为了SYN_SENT状态
    if (TCPState::state_summary(_receiver) == TCPReceiverStateSummary::SYN_RECV &amp;&amp;
        TCPState::state_summary(_sender) == TCPSenderStateSummary::CLOSED) {
        connect();
        return;
    }
    if (seg.length_in_sequence_space() &gt; 0) {
        send_empty = true;
    }
    //需要keep-alive
    if (send_empty &amp;&amp; TCPState::state_summary(_receiver) != TCPReceiverStateSummary::LISTEN) {
        _sender.send_empty_segment();
    }
    send_segments();
}

size_t TCPConnection::write(const string &amp;data) {
    size_t write_size = _sender.stream_in().write(data);  // 向写入缓冲写入数据
    send_segments();
    return write_size;
}

//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method
void TCPConnection::tick(const size_t ms_since_last_tick) {
    if (!_active)
        return;
    _time_since_last_segment_received += ms_since_last_tick;
    _sender.tick(ms_since_last_tick);
    // 重传次数太多时需要断开连接
    if (_sender.consecutive_retransmissions() &gt; TCPConfig::MAX_RETX_ATTEMPTS) {
        unclean_shutdown(true);
    }
    send_segments();
}

void TCPConnection::end_input_stream() {
    // 关闭发送端的写入通道
    _sender.stream_in().end_input();
    send_segments();
}

void TCPConnection::connect() {
    // 建立连接
    send_segments(true);
}

TCPConnection::~TCPConnection() {
    try {
        // 如果TCP连接是活跃状态则关闭连接
        if (active()) {
            cerr &lt;&lt; &quot;Warning: Unclean shutdown of TCPConnection\n&quot;;
            unclean_shutdown(true);
        }
    } catch (const exception &amp;e) {
        std::cerr &lt;&lt; &quot;Exception destructing TCP FSM: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
    }
}
// 将待发送的数据包加上期望接受到数据的ackno和当前自己作为接收端的滑动窗口大小
bool TCPConnection::send_segments(bool send_syn) {
    _sender.fill_window(send_syn || TCPState::state_summary(_receiver) == TCPReceiverStateSummary::SYN_RECV);
    TCPSegment seg;
    while (!_sender.segments_out().empty()) {
        // 从发送端的传输队列取出要发送的TCP数据报
        seg = _sender.segments_out().front();
        _sender.segments_out().pop();
        if (_receiver.ackno().has_value()) {  // 判断当前是否处于LISTEN状态
            // 向接收方发送ACK/下一个期望收到的ackno/当前接收窗口大小
            seg.header().ack = true;
            seg.header().ackno = _receiver.ackno().value();
            seg.header().win = _receiver.window_size();
        }
        // 出现异常设置RST位
        if (_need_send_rst) {
            _need_send_rst = false;
            seg.header().rst = true;
        }
        _segments_out.push(seg);
    }
    clean_shutdown();
    return true;
}
// 出现异常结束连接
void TCPConnection::unclean_shutdown(bool send_rst) {
    _receiver.stream_out().set_error();
    _sender.stream_in().set_error();
    _active = false;
    if (send_rst) {
        _need_send_rst = true;
        if (_sender.segments_out().empty()) {
            _sender.send_empty_segment();
        }
        send_segments();
    }
}
// 正常结束连接
bool TCPConnection::clean_shutdown() {
    if (_receiver.stream_out().input_ended() &amp;&amp; !(_sender.stream_in().eof())) {
        _linger_after_streams_finish = false;
    }
    if (TCPState::state_summary(_receiver) == TCPReceiverStateSummary::FIN_RECV &amp;&amp;
        TCPState::state_summary(_sender) == TCPSenderStateSummary::FIN_ACKED) {
        if (!_linger_after_streams_finish || time_since_last_segment_received() &gt;= 10 * _cfg.rt_timeout) {
            // 等待2MSL
            _active = false;
        }
    }
    return !_active;
}</code></pre><p id="40ca84a5-c2bb-4e76-b316-326c4b233b55" class="">到这里为止基本上完成了实验指导书的要求，构建出了可以使用的TCP协议栈。</p><h1 id="3620ce5a-bb00-4a88-8b86-fe4c004c0305" class="">替换掉Linux的TCP栈，使用以上构建的TCP协议栈进行通信</h1><ul id="32b49f76-b523-4cb6-88d9-92a3f97aa970" class="bulleted-list"><li style="list-style-type:disc">修改webget.cc，从Linux的TCP协议栈切换到以上构建的协议栈</li></ul><figure id="fcacb27c-eddf-4e83-82d3-e6bc2632b480" class="image"><a href="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%206.png"><img style="width:912px" src="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%206.png"/></a></figure><p id="b7009afe-c6fc-41b8-939e-a5ea7c4698f9" class="">成功获取了baidu.com网页上的信息。</p><p id="797c1fcd-b48a-4868-8e50-76f3a22e76c3" class="">
</p><ul id="4c3ce753-e05f-475a-8d12-00aa8ea745ca" class="bulleted-list"><li style="list-style-type:disc">实验平台提供了tcp_ipv4.cc文件，其使用了以上构筑的TCP协议栈来进行客户端和服务端的通信。虚拟出了tun144和tun145两块网卡进行通信。</li></ul><figure id="21b22f83-caeb-4edb-9521-6e36da17ae1f" class="image"><a href="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%207.png"><img style="width:2560px" src="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%207.png"/></a><figcaption>三次握手建立连接</figcaption></figure><figure id="ba5298d8-a4a1-4c7e-85b1-e58ff7aba6a7" class="image"><a href="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%208.png"><img style="width:2560px" src="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%208.png"/></a><figcaption>进行通信</figcaption></figure><figure id="0f45afa3-eb8f-4837-87b5-ba8eaedb3244" class="image"><a href="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%209.png"><img style="width:2560px" src="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%209.png"/></a><figcaption>四次挥手断开连接</figcaption></figure><h1 id="06172548-fcb9-41d6-b25d-6ea9a25817d3" class="">What’s More?</h1><p id="37c57cc8-828a-418f-901b-b3e8bf43833c" class="">以上是CS144课程的Lab0~Lab4的实验要求。代码可以通过其所有的测试样例。到此为止已经成功构建起了能够用于通信的TCP协议栈。</p><p id="c845358c-f756-4dfc-a616-9ed76b431c59" class="">在该平台之上可以进行拓展，实现自己需要的一些功能。</p><p id="77acff77-3160-45c7-bab7-e520a16367e0" class="">我设计探究的是<strong>零窗口问题</strong>和<strong>TCP的拥塞控制过程</strong>。</p><hr id="59424898-03f5-4df5-acc3-e38dbd43595f"/><blockquote id="741b193e-b47c-4f42-af08-1190a9562975" class="">说明：以下内容与CS144实验无关，为以下内容而修改的代码无法完美通过CS144的全部测试样例</blockquote><hr id="dbf33073-d9e7-4e91-9498-b9143ee9dc73"/><h1 id="c811005e-8935-46dd-bb60-ee4205123522" class="">零窗口问题</h1><p id="bd4b3832-8383-415b-8831-9237cffa4b09" class="">特别地，这里需要注意一个<strong>零窗口问题(Zero Window)</strong> ,即TCPReceiver的接收窗口大小为0，此时按照常规逻辑，TCPSender不会发送报文，从而无法获取接收窗口的状态，造成死锁。</p><p id="686ee174-f256-45a6-85d5-aaa6ecc2c6d5" class="">于是需要设计一个方法来解决这个问题。</p><p id="9a9cfbff-dca1-41ed-bf8b-d254d0ae46e7" class="">在CS144实验中，实验指导书要求当发送窗口为0时设置发送窗口为1：</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="594926d5-b783-496e-b115-3a7e9385cad2"><div style="font-size:1.5em"><span class="icon">⚠️</span></div><div style="width:100%">What should I do if the window size is zero? If the receiver has announced a window size of zero, <strong>the fill window method should act like the window size is one. </strong>The sender might end up sending a single byte that gets rejected (and not acknowledged) by the receiver, but this can also provoke the receiver into sending a new acknowledgment segment where it reveals that more space has opened up in its window. Without this, the sender would never learn that it was allowed to start sending again.</div></figure><p id="c848e492-5523-4023-88c9-8a43df546828" class="">查阅资料，我了解到TCP有一个零窗口计时器，于是我设计了一个<strong>零窗口计时器</strong>，用于统计零窗口经历的时长，如果计时器超时，则向TCP接收方发送1字节的探测报文。</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="07e5268a-17d2-42b9-9050-6f178a51f04a" class="code"><code class="language-C++">...
	size_t ZeroWindow_timer=0;
	bool ZeroWindow_timer_running=false;
	size_t DetectWindow_timeout=10;</code></pre><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4d916f49-5472-4089-88d9-293589527efd" class="code"><code class="language-C++">//设置当前发送窗口的大小
	size_t current_window_size=0;
	if(_window_size==0)//接收方窗口大小为0
	{
			if(ZeroWindow_timer_running==false)
			{
					ZeroWindow_timer=get_time_ms();
					ZeroWindow_timer_running=true;
			}
			else
			{
					ZeroWindow_timer=get_time_ms()-ZeroWindow_timer;
					if(ZeroWindow_timer &gt; DetectWindow_timeout)
					{
							current_window_size = 1;
					}
			}
	}
	else
	{
			current_window_size = _window_size;
	}</code></pre><p id="4aa345ef-2c00-4892-bd5a-079902bf8d8c" class="">于是就有了对这个问题的一个解决方案。当TCPSender收到TCPReceiver的回应，就可以根据当前的接受窗口大小来对发送窗口进行调整。</p><figure id="3a263bcd-7dd1-4e2a-bd74-13ce45955488" class="image"><a href="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%2010.png"><img style="width:528px" src="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%2010.png"/></a></figure><p id="7b8db410-f339-493f-bcf5-2898147c81c7" class="">由于自己设计的方法与实验要求不大符合，测试样例消耗时间显著增加。</p><p id="0adb08f8-e79c-40e2-8ae2-6cfe0acf5aaf" class="">以下是人为设置的零窗口状态观察，其原理是在运行./app/tcp_ipv4时使用参数-w手动指定窗口大小，然后发送很长的报文，使得出现零窗口状况。</p><figure id="1446ec93-d8da-4aa1-a152-a481def6afaf" class="image"><a href="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%2011.png"><img style="width:2560px" src="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%2011.png"/></a></figure><h1 id="2ed8f2b4-1843-4644-989b-c4a3940dd5dc" class="">TCP的拥塞控制—在CS144系统中缺失的部分</h1><p id="b2a29252-ed28-4e67-8684-6eead705e2ae" class="">CS144的实验设计基本上是一个庞大并且较完整的系统，其基本上实现了TCP的功能。但是其也有不够完善的地方。比如在设计中的接收窗口是一个固定值（在不使用参数指定窗口大小时为64000字节），窗口的变化仅限于</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="935155b4-6a89-40ce-84b6-0c09578944af"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">当前窗口大小 = 原始窗口大小 – 窗口已接收字节的大小</div></figure><p id="a3938bcb-47c0-4edc-9ddc-6f934fe54057" class="">其忽略了TCP拥塞控制中的慢启动、拥塞避免等过程。</p><p id="3bd7f3a3-8a65-4509-aa3a-c71018f308f1" class="">在CS144提供的实验平台上可以进行修改，复现TCP拥塞控制的过程。</p><p id="e39bbeb1-4f15-4d33-9fb7-71e4ed9bf6c9" class="">以下是对TCPReceiver的修改。</p><p id="d392d5cf-774f-4ad7-b409-92124d867915" class="">首先设定窗口值为1，慢启动阈值ssthresh为16。</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c1e01ff1-0b58-40e9-a629-b001ab004fac" class="code"><code class="language-C++">size_t pre_window_size=1;
size_t ssthresh=16;
int cnt=0;</code></pre><p id="53f5dfe0-0846-441c-80ed-063a7f22ae8c" class="">在window_size()函数里也进行了修改，使之符合慢启动和拥塞避免的工作方式。</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="64544b9e-4f7f-4dbf-a039-bb243f29e592" class="code"><code class="language-C++">size_t TCPReceiver::window_size() const {
    cnt++;
    if(cnt==15)//人为添加拥塞
    {
        ssthrech=pre_window_size/2;
        pre_window_size=1;
        cnt=10;
    }
    if(pre_window_size*2&lt;=ssthresh)//慢启动
    {
        pre_window_size=pre_window_size*2;
        return pre_window_size-_reassembler.stream_out().buffer_size();
    } 
    if(pre_window_size&lt;ssthrech&amp;&amp;pre_window_size*2&gt;ssthresh)
    {
        pre_window_size=ssthrech;
        return pre_window_size-_reassembler.stream_out().buffer_size();
    }
    pre_window_size=pre_window_size+1;//拥塞避免
    return pre_window_size-_reassembler.stream_out().buffer_size();
//    return _capacity - _reassembler.stream_out().buffer_size();   //原来的windows_size()函数
}</code></pre><p id="ad00ecc6-1c17-43c0-bb96-88e90f8b5e56" class="">cnt是人为设置的一个值，定义为传输次数。因为本地虚拟网卡间的TCP连接相当的稳定，在正常传输的情况下基本上不会出现异常，而使发送窗口不断的增加。所以人为设定每传输n次就出现一次异常传输，引起窗口的变化。</p><p id="516bdd9b-0d45-4269-a539-237797c213e7" class="">可以通过wireshark来观察传输过程。</p><figure id="2e065348-daa0-45ea-989c-387bfa0182f0" class="image"><a href="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%2012.png"><img style="width:2560px" src="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%2012.png"/></a></figure><p id="b3553ea7-e9af-440e-93ee-aec8f12cb28f" class="">以下是窗口尺寸的变化情况。（设定为刚开始传输时，第10次传输出现第一次超时重传，之后每五次传输出现一次超时）</p><figure id="53332c34-2992-405f-8b02-2160a5f246ed" class="image"><a href="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%2013.png"><img style="width:1750px" src="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%2013.png"/></a></figure><figure id="0be01832-26f8-4b38-ad0e-25e3477d7471" class="image"><a href="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%2014.png"><img style="width:1750px" src="%E5%8E%A6%E9%97%A8%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2023%E7%A7%8B%E5%AD%A3%E8%AF%BE%E7%A8%8B%E9%A1%B9%E7%9B%AE%202346e101a05f4b048c57e5d0d065cc62/Untitled%2014.png"/></a></figure><p id="7c0221a7-56d2-424a-9d13-615f816f715a" class="">从窗口值可以看出一开始窗口值指数增长，到达sstresh后执行拥塞避免算法，线性增加窗口值，发生超时后，窗口值设置为1，sstresh设置为当前窗口值的一半，重新开始执行慢启动和拥塞避免算法。</p><h1 id="b547b325-25d1-4324-8448-7074898b262e" class="">项目总结</h1><p id="81bc3ec2-6fb4-4f9c-bc50-713c5535eab8" class="">总结本项目，首先按照CS144实验指导书的要求，在Lab0、Lab1（在实验报告中未写出）中构建了流重组器，用于重组未按序到达的字节流，这个流重组器作为底层，向上层的TCP Sender和TCP Receiver提供服务。在Lab2中构建了TCP Receiver，在Lab3中构建了TCP Sender，在Lab4中将以上几个实验结合起来构建出TCP Connection，即是TCP的有限状态机。在构建过程中需要对TCP的特性有一定的了解，并按照RFC文档和课程的要求进行代码的编写。最后通过自己构建的这个TCP协议栈可以成功实现和互联网进行通信、用于客户和服务器间通信。在完成了CS144的实验任务后，利用构建出的TCP FSM，对TCP的一些特性进行了探究，例如TCP的拥塞控制：慢启动、拥塞避免算法。以及零窗口问题的设计探究，并使用Wireshark观察 TCP的连接过程。</p><h1 id="10ca0b1b-484a-446a-9431-81d87189294d" class="">参考资料：</h1><p id="9ff4c79e-a3f3-4ba7-be2f-97351a182e91" class="">[1]Ramakrishnan K, Floyd S, Black D. The TCP Congestion Control System[J]. RFC 3465, 2003. <a href="https://tools.ietf.org/html/rfc3465">https://tools.ietf.org/html/rfc3465</a></p><p id="bf16aa4b-898d-4bc0-bad7-fc4230825a1f" class="">[2]IETF. Computing TCP&#x27;s Retransmission Timer[J]. RFC 6298, 2011. <a href="https://tools.ietf.org/html/rfc6298">https://tools.ietf.org/html/rfc6298</a></p><p id="838ebbd9-fd9b-48d4-a422-06fd04067f3d" class="">[3]Allman M, Paxson V, Stevens W. TCP Congestion Control[J]. RFC 5681, 2009. <a href="https://tools.ietf.org/html/rfc5681">https://tools.ietf.org/html/rfc5681</a></p><p id="bcf7d7f4-5ecc-4ba4-8353-27136cec2d59" class="">[4]Welzl M, Nordmark E, Briscoe B. TCP: Specification of the Transmission Control Protocol[J]. RFC 9293, 2022. <a href="https://tools.ietf.org/html/rfc9293">https://tools.ietf.org/html/rfc9293</a></p><p id="184e32a5-1ef1-46ba-a5d0-8569c4b76ae8" class="">[5]计算机网络-自顶向下方法</p><p id="540471f6-bc40-4dc1-a53c-229b713468a5" class="">
</p><h3 id="a4538c5c-d6ca-46c4-8c0c-738b6c3ae95c" class="">项目成员</h3><p id="3cfe6e9a-825a-4513-b58f-6c958ef3ec95" class="">22920212204312  郑程硕  </p><p id="2372dea9-4800-45dc-be2b-eeeb3fcbd865" class="">本项目为单人项目，选题、代码、项目报告、PPT、汇报等内容均由本人完成。</p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>